const UNSIGNED_BYTE=5121,UNSIGNED_SHORT=5123,UNSIGNED_INT=5125,FLOAT=5126,ARRAY_BUFFER=34962,ELEMENT_ARRAY_BUFFER=34963,SPE_LAYER_TYPE_LIGHTING="light",SPE_LAYER_TYPE_COLOR="color",SPE_LAYER_TYPE_GRADIENT="gradient",SPE_LAYER_TYPE_NORMAL="normal",SPE_LAYER_TYPE_DEPTH="depth",SPE_LAYER_TYPE_TEXTURE="texture",SPE_LAYER_TYPE_NOISE="noise",SPE_LAYER_TYPE_FRESNEL="fresnel",SPE_LAYER_TYPE_POINTS="points",SPE_LAYER_TYPE_LINES="lines",SPE_LAYER_UNIFORM_TYPE_BOOL=0,SPE_LAYER_UNIFORM_TYPE_INT=1,SPE_LAYER_UNIFORM_TYPE_FLOAT=2,SPE_LAYER_UNIFORM_TYPE_VEC2=3,SPE_LAYER_UNIFORM_TYPE_VEC3=4,SPE_LAYER_UNIFORM_TYPE_VEC4=5,SPE_LAYER_UNIFORM_TYPE_COLOR=6,SPE_LAYER_UNIFORM_TYPE_ARRAY_INT=7,SPE_LAYER_UNIFORM_TYPE_ARRAY_FLOAT=8,SPE_LAYER_UNIFORM_TYPE_ARRAY_VEC2=9,SPE_LAYER_UNIFORM_TYPE_ARRAY_VEC3=10,SPE_LAYER_UNIFORM_TYPE_ARRAY_VEC4=11,SPE_LAYER_UNIFORM_TYPE_ARRAY_COLOR=12,SPE_LAYER_UNIFORM_TYPE_MAT3=13,SPE_LAYER_UNIFORM_TYPE_MAT4=14,SPE_LAYER_UNIFORM_TYPE_SAMPLER_2D=15,SPE_RENDERABLE_MESH3D=0,SPE_RENDERABLE_MESH2D=1,SPE_RENDERABLE_TEXT=2,SPE_RENDERABLE_RIGGING=3,SPE_MATERIAL_SIDE_FRONT=0,SPE_MATERIAL_SIDE_BACK=1,SPE_MATERIAL_SIDE_BOTH=2,SPE_COLOR_MAIN_BLUE=3447804,SPE_COLOR_DEFAULT=8026746,SPE_COLOR_RED=16603997,SPE_COLOR_GREEN=6218333,SPE_COLOR_PURPLE=13192447,SPE_COLOR_PINK=16741879,SPE_COLOR_YELLOW=15711266,SPE_COLOR_GRAY_DARK=7105644,SPE_COLOR_BLACK=7105644,SPE_TEXT_VERTICAL_ALIGN_TOP=1,SPE_TEXT_VERTICAL_ALIGN_MIDDLE=2,SPE_TEXT_VERTICAL_ALIGN_BOTTOM=3,SPE_TEXT_HORIZONTAL_ALIGN_LEFT=1,SPE_TEXT_HORIZONTAL_ALIGN_RIGHT=2,SPE_TEXT_HORIZONTAL_ALIGN_CENTER=3,SPE_TEXT_HORIZONTAL_ALIGN_JUSTIFY=4,SPE_TEXT_TRANSFORM_STANDARD=1,SPE_TEXT_TRANSFORM_UPPERCASE=2,SPE_TEXT_TRANSFORM_LOWERCASE=3,SPE_TEXT_TRAVELDIR_TO_RIGHT=1,SPE_TEXT_TRAVELDIR_TO_LEFT=-1,SPE_BLENDING_NORMAL=0,SPE_BLENDING_MULTIPLY=1,SPE_BLENDING_SCREEN=2,SPE_BLENDING_OVERLAY=3,SPE_RUNTIME_VIEWMODE_FULLSCREEN=1,SPE_RUNTIME_VIEWMODE_CUSTOM_SIZE=2,SPE_RUNTIME_VIEWMODE_FULL_WIDTH=3,SPE_RUNTIME_VIEWMODE_FULL_HEIGHT=4,SPE_RUNTIME_QUALITY_HIGH="high",SPE_RUNTIME_QUALITY_MIDDLE="middle",SPE_RUNTIME_QUALITY_LOW="low",SPE_RUNTIME_QUALITY_DEFAULT="default";SPE.QualityModifiers={SphereGeometry:{widthSegments:{scalers:{high:2,middle:1,low:.5,default:1},minValue:1,maxValue:128},heightSegments:{scalers:{high:2,middle:1,low:.5,default:1},minValue:1,maxValue:128}},CubeGeometry:{cornerSegments:{scalers:{high:2,middle:1,low:.5,default:1},minValue:1,maxValue:128}},ConeGeometry:{radialSegments:{scalers:{high:2,middle:1,low:.5,default:1},minValue:1,maxValue:64},heightSegments:{scalers:{high:2,middle:1,low:.5,default:1},minValue:1,maxValue:64},cornerSegments:{scalers:{high:2,middle:1,low:.5,default:1},minValue:1,maxValue:64}},CylinderGeometry:{radialSegments:{scalers:{high:2,middle:1,low:.5,default:1},minValue:1,maxValue:64},cornerSegments:{scalers:{high:2,middle:1,low:.5,default:1},minValue:1,maxValue:64}},EllipseGeometry:{spikes:{scalers:{high:2,middle:1,low:.5,default:1},minValue:1,maxValue:64}},PolygonGeometry:{extrudeBevelSegments:{scalers:{high:2,middle:1,low:.5,default:1},minValue:1,maxValue:16}},RectangleGeometry:{extrudeBevelSegments:{scalers:{high:2,middle:1,low:.5,default:1},minValue:1,maxValue:16}},StarGeometry:{extrudeBevelSegments:{scalers:{high:2,middle:1,low:.5,default:1},minValue:1,maxValue:16}},TorusGeometry:{radialSegments:{scalers:{high:2,middle:1,low:.5,default:1},minValue:1,maxValue:64},tubularSegments:{scalers:{high:2,middle:1,low:.5,default:1},minValue:1,maxValue:128}}};class SpeGltfDecoder{constructor(e){this.mGltfSceneGraph=e,this.mSceneGraph=null,this.mSceneCamera=null,this.mSceneOptions={},this.mNodes=[],this.mCameras=[],this.mLights=[],this.mGeometries=[],this.mGeometriesSpe=[],this.mAccessors=[],this.mMaterials=[]}decode(e){e&&(this.mGltfSceneGraph=e),this.mSceneGraph=new SpeScene,this.mSceneCamera=null,this.mSceneOptions={},this.mNodes=[this.mSceneGraph],this.mObjects={},this.mCameras=[],this.mLights=[],this.mGeometries=[],this.mGeometriesSpe=[],this.mAccessors=[],this.mMaterials=[],this.mInteractionStates={},void 0!==this.mGltfSceneGraph.spline&&(this.mSceneOptions.usePrimitives=void 0===this.mGltfSceneGraph.spline.usePrimitives||this.mGltfSceneGraph.spline.usePrimitives,this.mSceneOptions.useOrbitControls=void 0===this.mGltfSceneGraph.spline.useOrbitControls||this.mGltfSceneGraph.spline.useOrbitControls,this.mSceneOptions.bgColor=void 0!==this.mGltfSceneGraph.spline.bgColor?this.mGltfSceneGraph.spline.bgColor:new THREE.Color(1644825),this.mSceneOptions.bgAlpha=void 0!==this.mGltfSceneGraph.spline.bgAlpha?this.mGltfSceneGraph.spline.bgAlpha:0,this.mSceneOptions.orbitDamped=void 0!==this.mGltfSceneGraph.spline.orbitDamped&&this.mGltfSceneGraph.spline.orbitDamped,this.mSceneOptions.orbitTarget=void 0!==this.mGltfSceneGraph.spline.orbitTarget?this.mGltfSceneGraph.spline.orbitTarget:[0,0,0],this.mSceneOptions.cameraType=void 0!==this.mGltfSceneGraph.spline.cameraType?this.mGltfSceneGraph.spline.cameraType:"Orthographic",this.mSceneOptions.cameraRotate=void 0===this.mGltfSceneGraph.spline.cameraRotate||this.mGltfSceneGraph.spline.cameraRotate,this.mSceneOptions.cameraPan=void 0===this.mGltfSceneGraph.spline.cameraPan||this.mGltfSceneGraph.spline.cameraPan,this.mSceneOptions.cameraZoom=void 0===this.mGltfSceneGraph.spline.cameraZoom||this.mGltfSceneGraph.spline.cameraZoom,this.mSceneOptions.viewMode=void 0!==this.mGltfSceneGraph.spline.viewMode?this.mGltfSceneGraph.spline.viewMode:SPE_RUNTIME_VIEWMODE_FULLSCREEN,this.mSceneOptions.viewWidth=void 0!==this.mGltfSceneGraph.spline.viewWidth?this.mGltfSceneGraph.spline.viewWidth:1024,this.mSceneOptions.viewHeight=void 0!==this.mGltfSceneGraph.spline.viewHeight?this.mGltfSceneGraph.spline.viewHeight:768,this.mSceneOptions.quality=void 0!==this.mGltfSceneGraph.spline.quality?this.mGltfSceneGraph.spline.quality:SPE_RUNTIME_QUALITY_DEFAULT);const t="function"==typeof Interaction;if(t){if(SPE.CachedImages={},this.mGltfSceneGraph.spline&&this.mGltfSceneGraph.spline.images){const e=this.mGltfSceneGraph.spline.images;for(const[t,i]of Object.entries(e)){const e=new Image;e.src=i.url,SPE.CachedImages[t]=e}}if(SPE.CachedTextures={},this.mGltfSceneGraph.spline&&this.mGltfSceneGraph.spline.textures){const e=this.mGltfSceneGraph.spline.textures;for(const[t,i]of Object.entries(e)){const e=i.image,a=SPE.CachedImages[e],r=new THREE.Texture(a,i.mapping,i.wrap[0],i.wrap[1],i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding);r.offset.fromArray(i.offset),r.repeat.fromArray(i.repeat),r.center.fromArray(i.center),r.updateMatrix(),SPE.CachedTextures[t]=r}}if(this.mGltfSceneGraph.spline&&this.mGltfSceneGraph.spline.interactionStates){const e=this.mGltfSceneGraph.spline.interactionStates;this.mGltfSceneGraph.spline.textures;for(const[t,i]of Object.entries(e))this.mInteractionStates[t]=(new InteractionState).fromJSON(i,SPE.CachedTextures)}}const i=this.mGltfSceneGraph.cameras||[];for(let e=0;e<i.length;e++)this._decodeCamera(i[e]);if(this.mGltfSceneGraph.extensions&&this.mGltfSceneGraph.extensions.KHR_lights_punctual&&this.mGltfSceneGraph.extensions.KHR_lights_punctual.lights){const e=this.mGltfSceneGraph.extensions.KHR_lights_punctual.lights;for(let t=0;t<e.length;t++)this._decodeLight(e[t])}this._constructGeometricData();const a=this.mGltfSceneGraph.materials||[];for(let e=0;e<a.length;e++)this._decodeMaterial(a[e]);const r=this.mGltfSceneGraph.meshes_spe||[];for(let e=0;e<r.length;e++)this._decodeSpeGeometry(r[e]);const s=this.mGltfSceneGraph.meshes||[];for(let e=0;e<s.length;e++)this._decodeGeometry(s[e]);const n=this.mGltfSceneGraph.nodes||[];for(let e=1;e<n.length;e++)this._decodeNode(n[e]);if(t&&this.mGltfSceneGraph.spline&&this.mGltfSceneGraph.spline.interactions){const e=this.mGltfSceneGraph.spline.interactions;for(let t=0;t<n.length;t++){const i=n[t];if(void 0!==i.spe_interaction){const a=i.spe_interaction;if(a<e.length&&a>=0){const i=e[a],r=this.mInteractionStates,s=this.mObjects;this.mNodes[t].interaction.fromJSON(i,s,r)}}}}const o=this.mGltfSceneGraph.nodes[0],h=new SpeStack;for(let e=0;e<o.children.length;e++)h.push([o.children[e],this.mSceneGraph]);for(;!h.empty();){const e=h.pop(),t=e[0],i=e[1];if(t<this.mNodes.length&&t>=0){const e=this.mNodes[t];if(!e)continue;i&&i.add(e);const a=this.mGltfSceneGraph.nodes[t].children;if(void 0!==a)for(let t=0;t<a.length;t++)h.push([a[t],e])}}if(void 0!==this.mGltfSceneGraph.spline&&this.mGltfSceneGraph.spline.fog){const e=this.mGltfSceneGraph.spline.fog,t=void 0!==e.color?e.color:16777215,i=void 0!==e.near?e.near:500,a=void 0!==e.far?e.far:2e3;this.mSceneGraph.fog=new THREE.Fog(t,i,a)}if(void 0!==this.mGltfSceneGraph.spline&&void 0!==this.mGltfSceneGraph.spline.mainCameraIndex){const e=this.mGltfSceneGraph.spline.mainCameraIndex;e<this.mNodes.length&&e>=0&&(this.mSceneCamera=this.mNodes[e])}return[this.mSceneGraph,this.mSceneCamera,this.mSceneOptions]}_decodeCamera(e){if("Perspective"===e.type){const t=e.spe_options||{},i=new THREE.PerspectiveCamera(e.perspective.yfov,e.perspective.aspectRatio,e.perspective.znear,e.perspective.zfar);i.zoom=void 0!==t.zoom?t.zoom:1,this.mCameras.push(i)}else if("Orthographic"===e.type){const t=e.spe_options||{},i=new THREE.OrthographicCamera(-e.orthographic.xmag/2,e.orthographic.xmag/2,e.orthographic.ymag/2,-e.orthographic.ymag/2,e.orthographic.znear,e.orthographic.zfar);i.zoom=void 0!==t.zoom?t.zoom:1,this.mCameras.push(i)}else console.error("SpeGltfDecoder::_decodeCamera >>> unsupported camera type: ",e.type)}_decodeLight(e){if("hemispheric"===e.type){const t=(new THREE.Color).fromArray(void 0!==e.color?e.color:[1,1,1]),i=(new THREE.Color).setHex(8553090),a=e.intensity?e.intensity:1;this.mLights.push(new THREE.HemisphereLight(t,i,a))}else if("directional"===e.type){const t=new THREE.DirectionalLight((new THREE.Color).fromArray(e.color),e.intensity),i=e.shadows||{};t.castShadow=void 0!==i.castShadow&&i.castShadow,t.shadow.camera.right=void 0!==i.shadowmapViewRight?i.shadowmapViewRight:1250,t.shadow.camera.left=void 0!==i.shadowmapViewLeft?i.shadowmapViewLeft:-1250,t.shadow.camera.top=void 0!==i.shadowmapViewTop?i.shadowmapViewTop:1250,t.shadow.camera.bottom=void 0!==i.shadowmapViewBottom?i.shadowmapViewBottom:-1250,t.shadow.camera.near=void 0!==i.shadowmapViewNear?i.shadowmapViewNear:1,t.shadow.camera.far=void 0!==i.shadowmapViewFar?i.shadowmapViewFar:2500,this.mLights.push(t)}else if("point"===e.type){const t=(new THREE.Color).fromArray(void 0!==e.color?e.color:[1,1,1]),i=e.intensity?e.intensity:1,a=void 0!==e.range?e.range:0,r=void 0!==e.decay?e.decay:1,s=new THREE.PointLight(t,i,a,r),n=e.shadows||{};s.castShadow=void 0!==n.castShadow&&n.castShadow,s.shadow.camera.near=void 0!==n.shadowmapViewNear?n.shadowmapViewNear:1,s.shadow.camera.far=void 0!==n.shadowmapViewFar?n.shadowmapViewFar:2500,this.mLights.push(s)}else if("spot"===e.type){const t=(new THREE.Color).fromArray(void 0!==e.color?e.color:[1,1,1]),i=e.intensity?e.intensity:1,a=void 0!==e.range?e.range:0,r=void 0!==e.decay?e.decay:1,s=void 0!==e.innerConeAngle?e.innerConeAngle:Math.PI/3,n=void 0!==e.penumbra?e.penumbra:0,o=new THREE.SpotLight(t,i,a,s,n,r),h=e.shadows||{};o.castShadow=void 0!==h.castShadow&&h.castShadow,o.shadow.camera.fov=void 0!==h.shadowmapViewFov?h.shadowmapViewFov:2*THREE.MathUtils.RAD2DEG*s,o.shadow.camera.near=void 0!==h.shadowmapViewNear?h.shadowmapViewNear:1,o.shadow.camera.far=void 0!==h.shadowmapViewFar?h.shadowmapViewFar:2500,this.mLights.push(o)}else console.error("SpeGltfDecoder::_decodeLight >>> unsupported light type: ",e.type)}_constructGeometricData(){const e=this.mGltfSceneGraph.buffers,t=[];for(let i=0;i<e.length;i++)t.push(this._decodeBuffer(e[i]));const i=this.mGltfSceneGraph.bufferViews,a=[];for(let e=0;e<i.length;e++)a.push(this._decodeBufferView(i[e],t));const r=this.mGltfSceneGraph.accessors;for(let e=0;e<r.length;e++)this.mAccessors.push(this._decodeAccessor(r[e],a))}_decodeBuffer(e){const t=e.byteLength,i=e.uri;if(i.indexOf("base64")){const e=i.slice(i.indexOf("base64")+7),a=atob(e),r=new Uint8Array(e.length);for(let e=0;e<a.length;e++)r[e]=a.charCodeAt(e);return{data:r,length:t}}return i.indexOf(".bin")?(console.error("SpeGltfDecoder::_decodeBuffer >>> encode-from-.bin is not implement yet"),""):(console.error("SpeGltfDecoder::_decodeBuffer >>> invalid options to parse buffer data"),"")}_decodeBufferView(e,t){const i=e.byteLength,a=e.byteOffset,r=e.buffer,s=e.target;if(r<t.length&&r>=0){return{data:t[r].data.slice(a,a+i),length:i,target:s}}return console.error("SpeGltfDecoder::_decodeBufferView >>> index-out-of-range in buffers array"),{}}_decodeAccessor(e,t){const i=e.bufferView,a=e.byteOffset,r=e.componentType,s=e.count,n=e.type;if(i<t.length&&i>=0){const e=t[i].data,o=this._getAccessorItemSize(n),h=s*o*this._getAccessorComponentSize(r),l=e.slice(a,a+h);let m=null;return r===UNSIGNED_SHORT?m=this._createUint16Buffer(l):r===UNSIGNED_INT?m=this._createUint32Buffer(l):r===FLOAT&&(m=this._createFloat32Buffer(l)),m?this._createBufferAttribute(m,o):(console.error("SpeGltfDecoder::_decodeAccessor >>> invalid component-type given"),null)}return console.error("SpeGltfDecoder::_decodeAccessor >>> index-out-of-range in bufferViews array"),null}_decodeMaterial(e){let[t,i]=Object.entries(e)[0];void 0!==i.extensions&&void 0!==i.extensions.KHR_materials_common?this._decodeSimpleMaterial(i.extensions.KHR_materials_common,i.spe_options,i.spe_layers):this._decodePbrMaterial(i)}_decodeSimpleMaterial(e,t,i){const a=e.technique||"PHONG",r=e.values||{},s=t||{},n=i||{};if("PHONG"===a){const e=(new THREE.Color).fromArray(void 0!==r.diffuse?r.diffuse:[.5,.5,.5]),t=(new THREE.Color).fromArray(void 0!==r.specular?r.specular:[.5,.5,.5]),i=(new THREE.Color).fromArray(void 0!==r.emission?r.emission:[0,0,0]),a=void 0!==r.shininess?r.shininess:32,o=void 0!==r.transparent&&r.transparent,h=void 0!==r.transparency?r.transparency:1,l=void 0===s.visible||s.visible,m=void 0!==s.wireframe&&s.wireframe,d=void 0!==s.side?s.side:THREE.FrontSide,c=void 0!==s.flatShading&&s.flatShading,u=new SpePhongMaterial(n,{color:e,specular:t,emissive:i,shininess:a,transparent:o,opacity:h,flatShading:c,side:d,wireframe:m,visible:l});this.mMaterials.push(u)}else if("LAMBERT"===a){const e=(new THREE.Color).fromArray(void 0!==r.diffuse?r.diffuse:[.5,.5,.5]),t=(new THREE.Color).fromArray(void 0!==r.emission?r.emission:[0,0,0]),i=void 0!==r.transparent&&r.transparent,a=void 0!==r.transparency?r.transparency:1,o=void 0===s.visible||s.visible,h=void 0!==s.wireframe&&s.wireframe,l=void 0!==s.side?s.side:THREE.FrontSide,m=void 0!==s.flatShading&&s.flatShading,d=new SpeLambertMaterial(n,{color:e,emissive:t,transparent:i,opacity:a,flatShading:m,side:l,wireframe:h,visible:o});this.mMaterials.push(d)}else if("CONSTANT"===a){const e=(new THREE.Color).fromArray(void 0!==r.ambient?r.ambient:[.5,.5,.5]),t=void 0!==r.transparent&&r.transparent,i=void 0!==r.transparency?r.transparency:1,a=void 0===s.visible||s.visible,o=void 0!==s.wireframe&&s.wireframe,h=void 0!==s.side?s.side:THREE.FrontSide,l=void 0!==s.flatShading&&s.flatShading,m=new SpeBasicMaterial(n,{color:e,transparent:t,opacity:i,flatShading:l,side:h,wireframe:o,visible:a});this.mMaterials.push(m)}else if("TOON"===a){const e=(new THREE.Color).fromArray(void 0!==r.ambient?r.ambient:[.5,.5,.5]),t=void 0!==r.transparent&&r.transparent,i=void 0!==r.transparency?r.transparency:1,a=void 0===s.visible||s.visible,o=void 0!==s.wireframe&&s.wireframe,h=void 0!==s.side?s.side:THREE.FrontSide,l=void 0!==s.flatShading&&s.flatShading,m=new SpeToonMaterial(n,{color:e,transparent:t,opacity:i,flatShading:l,side:h,wireframe:o,visible:a});this.mMaterials.push(m)}else if("PHYSICAL"===a){const e=(new THREE.Color).fromArray(void 0!==r.ambient?r.ambient:[.5,.5,.5]),t=void 0!==r.transparent&&r.transparent,i=void 0!==r.transparency?r.transparency:1,a=void 0!==r.roughness?r.roughness:.3,o=void 0!==r.metalness?r.metalness:0,h=void 0!==r.reflectivity?r.reflectivity:.5,l=void 0===s.visible||s.visible,m=void 0!==s.wireframe&&s.wireframe,d=void 0!==s.side?s.side:THREE.FrontSide,c=void 0!==s.flatShading&&s.flatShading,u=new SpePhysicalMaterial(n,{color:e,transparent:t,opacity:i,roughness:a,metalness:o,reflectivity:h,flatShading:c,side:d,wireframe:m,visible:l});this.mMaterials.push(u)}else if("ARRAY"===a){const e=void 0!==r.techniques?r.techniques:new Array(n.length).fill("CONSTANT"),t=[];for(let i=0;i<n.length;i++)"CONSTANT"===e[i]?t.push(new SpeBasicMaterial(n[i],{})):"LAMBERT"===e[i]?t.push(new SpeLambertMaterial(n[i],{})):"PHONG"===e[i]?t.push(new SpePhongMaterial(n[i],{})):"TOON"===e[i]?t.push(new SpeToonMaterial(n[i],{})):"PHYSICAL"===e[i]?t.push(new SpePhysicalMaterial(n[i],{})):(console.error(`SpeGltfDecoder::_decodeSimpleMaterial >>> unsupported technique (${e[i]}) for element of array of materials`),t.push(new SpeBasicMaterial(n[i],{})));this.mMaterials.push(t)}else console.error("SpeGltfDecoder::_decodeSimpleMaterial >>> unsupported material type: ",e.technique)}_decodePbrMaterial(e){}_decodeSpeGeometry(e){const t=void 0!==e.type?e.type:"SphereGeometry",i=this._applyQualityScalers(t,void 0!==e.parameters?{...e.parameters}:{width:100,height:100,depth:100});if("CharacterGeometry"===t){SpeLoadCharData(void 0!==i.char?i.char:".",void 0!==i.fontFamily?i.fontFamily:"roboto_regular",void 0!==i.lod?i.lod:1),this.mGeometriesSpe.push(i)}else{const e=(0,SPE[t].build)(i);this.mGeometriesSpe.push(e)}}_applyQualityScalers(e,t){if(void 0===SPE.QualityModifiers[e])return t;const i={},a=this.mSceneOptions.quality;for(const[r,s]of Object.entries(t)){if(void 0===SPE.QualityModifiers[e][r]){i[r]=s;continue}const t=SPE.QualityModifiers[e][r].minValue,n=SPE.QualityModifiers[e][r].maxValue,o=SPE.QualityModifiers[e][r].scalers[a];i[r]=Math.max(t,Math.min(n,o*s))}return i}_decodeGeometry(e){const t=e.primitives,i=e.groups,a=e.parameters,r=t[0],s=r.indices,n=r.attributes,o=this.mAccessors[s],h={};for(let e in n)h[e]=this.mAccessors[n[e]];const l=new THREE.BufferGeometry;o&&l.setIndex(o);for(let e in h)l.setAttribute(e.toLowerCase(),h[e]);if(void 0!==i)for(let e=0;e<i.length;e++)l.addGroup(i[e].start,i[e].count,i[e].materialIndex);if(void 0!==a){const e=new THREE.Vector3;l.computeBoundingBox(),l.boundingBox.getSize(e);const t=void 0!==a.width?a.width:e.x,i=void 0!==a.height?a.height:e.y,r=void 0!==a.depth?a.depth:e.z;l.scale(Math.abs(e.x)<1e-5?1:t/e.x,Math.abs(e.y)<1e-5?1:i/e.y,Math.abs(e.z)<1e-5?1:r/e.z),l.userData={type:"NonParametricGeometry",parameters:{width:t,height:i,depth:r}}}this.mGeometries.push(l)}_decodeNode(e){if(void 0!==e.camera){const t=e.camera;if(t<this.mCameras.length&&t>=0){const i=this.mCameras[t];i.position.copy((new THREE.Vector3).fromArray(e.translation?e.translation:[0,0,0])),i.quaternion.copy((new THREE.Quaternion).fromArray(e.rotation?e.rotation:[0,0,0,1])),i.updateMatrix(),this.mNodes.push(i)}else console.error("SpeGltfDecoder::_decodeNode >>> couldnt create node for associated camera (index out of bounds)")}else if(void 0!==e.mesh_spe){const t=e.mesh_spe;let i=null;t<this.mGeometriesSpe.length&&t>=0?i=this.mGeometriesSpe[t]:(console.warn("SpeGltfDecoder::_decodeNode >>> couldnt grab any associated geometry for a mesh-node (index out of bounds). Creating a default sphere instead"),i=new THREE.SphereBufferGeometry(1,10,10));let a=null;if(void 0!==e.material){const t=e.material;t<this.mMaterials.length&&t>=0?a=this.mMaterials[t]:console.warn("SpeGltfDecoder::_decodeNode >>> couldnt grab any associated material for a mesh-node (index out of bounds)")}a||(console.error("SpeGltfDecoder::_decodeNode >>> mesh-node doesnt have a material. Creating a default phong-material instead"),a=new SpePhongMaterial({},{color:new THREE.Color(16777215),specular:new THREE.Color(16777215)}));const r=void 0!==e.type?e.type:"mesh3d";let s=null;"mesh3d"===r?s=new SpeMesh3D(i,a):"mesh2d"===r?s=new SpeMesh2D(i,a):"text"===r?s=new SpeTextContainer(i,a):"character"===r?s=new SpeTextChar3D(i,a):(console.error(`SpeGltfDecoder::_decodeNode >>> mesh-type ${r} not supported`),s=new SpeMesh3D(i,a)),s.visible=void 0===e.visible||e.visible,s.castShadow=void 0===e.castShadow||e.castShadow,s.receiveShadow=void 0===e.receiveShadow||e.receiveShadow,s.position.copy((new THREE.Vector3).fromArray(e.translation?e.translation:[0,0,0])),s.quaternion.copy((new THREE.Quaternion).fromArray(e.rotation?e.rotation:[0,0,0,1])),s.scale.copy((new THREE.Vector3).fromArray(e.scale?e.scale:[1,1,1])),s.hiddenMatrix.copy((new THREE.Matrix4).fromArray(e.hiddenMatrix?e.hiddenMatrix:[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])),s.updateMatrix(),this.mNodes.push(s);const n=void 0!==e.uuid?e.uuid:THREE.MathUtils.generateUUID();this.mObjects[n]=s,e.spe_cloner&&(s.cloner=new Cloner(s).fromJSON(e.spe_cloner_data),s.add(s.cloner))}else if(void 0!==e.mesh){const t=e.mesh;let i=null;t<this.mGeometries.length&&t>=0?i=this.mGeometries[t]:(console.warn("SpeGltfDecoder::_decodeNode >>> couldnt grab any associated geometry for a mesh-node (index out of bounds). Creating a default sphere instead"),i=new THREE.SphereBufferGeometry(1,10,10));let a=null;if(void 0!==e.material){const t=e.material;t<this.mMaterials.length&&t>=0?a=this.mMaterials[t]:console.warn("SpeGltfDecoder::_decodeNode >>> couldnt grab any associated material for a mesh-node (index out of bounds)")}a||(console.warn("SpeGltfDecoder::_decodeNode >>> mesh-node doesnt have a material. Creating a default phong-material instead"),a=new SpePhongMaterial({},{color:new THREE.Color(16777215),specular:new THREE.Color(16777215)}));const r=new SpeMesh3D(i,a);r.visible=void 0===e.visible||e.visible,r.castShadow=void 0===e.castShadow||e.castShadow,r.receiveShadow=void 0===e.receiveShadow||e.receiveShadow,r.position.copy((new THREE.Vector3).fromArray(e.translation?e.translation:[0,0,0])),r.quaternion.copy((new THREE.Quaternion).fromArray(e.rotation?e.rotation:[0,0,0,1])),r.scale.copy((new THREE.Vector3).fromArray(e.scale?e.scale:[1,1,1])),r.hiddenMatrix.copy((new THREE.Matrix4).fromArray(e.hiddenMatrix?e.hiddenMatrix:[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])),r.updateMatrix(),this.mNodes.push(r);const s=void 0!==e.uuid?e.uuid:THREE.MathUtils.generateUUID();this.mObjects[s]=r,e.spe_cloner&&(r.cloner=new Cloner(r).fromJSON(e.spe_cloner_data),r.add(r.cloner))}else if(void 0!==e.extensions&&void 0!==e.extensions.KHR_lights_punctual&&void 0!==e.extensions.KHR_lights_punctual.light){const t=e.extensions.KHR_lights_punctual.light;if(t<this.mLights.length&&t>=0){const i=this.mLights[t];if(i.position.copy((new THREE.Vector3).fromArray(e.translation?e.translation:[0,0,0])),"SpotLight"===i.type||"DirectionalLight"===i.type){const t=(new THREE.Quaternion).fromArray(e.rotation?e.rotation:[0,0,0,1]),a=(new THREE.Matrix4).makeRotationFromQuaternion(t),r=new THREE.Vector3(a.elements[8],a.elements[9],a.elements[10]);i.target.position.x=i.position.x+r.x,i.target.position.y=i.position.y+r.y,i.target.position.z=i.position.z+r.z}i.visible=void 0===e.visible||e.visible,this.mNodes.push(i)}else console.error("SpeGltfDecoder::_decodeNode >>> couldnt create node for associated light (index out of bounds)")}else if(e.spe_empty_object){const t=new SpeEmptyObject;t.position.copy((new THREE.Vector3).fromArray(e.translation?e.translation:[0,0,0])),t.quaternion.copy((new THREE.Quaternion).fromArray(e.rotation?e.rotation:[0,0,0,1])),t.scale.copy((new THREE.Vector3).fromArray(e.scale?e.scale:[1,1,1])),t.hiddenMatrix.copy((new THREE.Matrix4).fromArray(e.hiddenMatrix?e.hiddenMatrix:[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])),t.updateMatrix(),this.mNodes.push(t);const i=void 0!==e.uuid?e.uuid:THREE.MathUtils.generateUUID();this.mObjects[i]=t}else{console.warn("SpeGltfDecoder::_decodeNode >>> Unsupported node, creating a default THREE.Object3D instead");const t=new THREE.Object3D;t.position.copy((new THREE.Vector3).fromArray(e.translation?e.translation:[0,0,0])),t.quaternion.copy((new THREE.Quaternion).fromArray(e.rotation?e.rotation:[0,0,0,1])),t.scale.copy((new THREE.Vector3).fromArray(e.scale?e.scale:[1,1,1])),this.mNodes.push(t)}}_getAccessorItemSize(e){return"SCALAR"===e?1:"VEC2"===e?2:"VEC3"===e?3:"VEC4"===e?4:"MAT4"===e?16:(console.error("SpeGltfDecoder::_getAccessorItemSize >>> invalid item-type"),1)}_getAccessorComponentSize(e){return e===UNSIGNED_BYTE?1:e===UNSIGNED_SHORT?2:e===UNSIGNED_INT?4:e===FLOAT?4:(console.error("SpeGltfDecoder::_getAccessorComponentSize >>> invalid component-type"),1)}_createUint16Buffer(e){return new Uint16Array(e.buffer)}_createUint32Buffer(e){return new Uint32Array(e.buffer)}_createFloat32Buffer(e){const t=new Float32Array(e.length/Float32Array.BYTES_PER_ELEMENT),i=new DataView(new ArrayBuffer(Float32Array.BYTES_PER_ELEMENT));for(let a=0;a<t.length;a++)i.setUint8(0,e[4*a+0]),i.setUint8(1,e[4*a+1]),i.setUint8(2,e[4*a+2]),i.setUint8(3,e[4*a+3]),t[a]=i.getFloat32(0,!0);return t}_createBufferAttribute(e,t){return"Float32Array"===e.constructor.name?new THREE.Float32BufferAttribute(e,t):"Uint16Array"===e.constructor.name?new THREE.Uint16BufferAttribute(e,t):"Uint32Array"===e.constructor.name?new THREE.Uint32BufferAttribute(e,t):(console.error("SpeGltfDecoder::_createBufferAttribute >>> unsupported buffer-array-type"),null)}}class SpeIMesh extends THREE.Mesh{constructor(e,t){super(e,t),this.mLocalTransform=new THREE.Matrix4,this.mInteraction="function"==typeof Interaction?new Interaction(this):null}get interaction(){return this.mInteraction}set interaction(e){this.mInteraction=e}get hiddenMatrix(){return this.mLocalTransform}set hiddenMatrix(e){this.mLocalTransform.copy(e)}updateGeometry(e){this.geometry.copy(e)}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(null===this.parent?this.matrixWorld.multiplyMatrices(this.mLocalTransform,this.matrix):(this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.mLocalTransform),this.matrixWorld.multiplyMatrices(this.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let i=0,a=t.length;i<a;i++)t[i].updateMatrixWorld(e)}updateWorldMatrix(e,t){var i=this.parent;if(!0===e&&null!==i&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.multiplyMatrices(this.mLocalTransform,this.matrix):(this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.mLocalTransform),this.matrixWorld.multiplyMatrices(this.matrixWorld,this.matrix)),!0===t)for(var a=this.children,r=0,s=a.length;r<s;r++)a[r].updateWorldMatrix(!1,!0)}shallowClone(e){return new this.constructor(this.geometry,this.material).shallowCopy(this,e)}shallowCopy(e,t=!0){let i=e.children;if(e.children=[],super.copy(e),e.children=i,this.userDataFromJson(this.userData),!0===t)for(let t=0,a=i.length;t<a;++t){let i=e.children[t];!0===i.userData.isEntity&&this.add(i.shallowClone())}return this}userDataFromJson(e){this.userData=e,this.userData.positionToCenter=new THREE.Vector3,void 0!==e.hiddenMatrix&&(this.userData.hiddenMatrix=(new THREE.Matrix4).fromArray(e.hiddenMatrix.elements)),void 0===e.lock&&(this.userData.lock=!1)}}class SpeMesh3D extends SpeIMesh{constructor(e,t){super(e,t)}}class SpeMesh2D extends SpeIMesh{constructor(e,t){super(e,t)}}class SpeEmptyObject extends THREE.Group{constructor(){super(),this.mLocalTransform=new THREE.Matrix4,this.mInteraction="function"==typeof Interaction?new Interaction(this):null}get interaction(){return this.mInteraction}set interaction(e){this.mInteraction=e}get hiddenMatrix(){return this.mLocalTransform}set hiddenMatrix(e){this.mLocalTransform.copy(e)}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(null===this.parent?this.matrixWorld.multiplyMatrices(this.mLocalTransform,this.matrix):(this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.mLocalTransform),this.matrixWorld.multiplyMatrices(this.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let i=0,a=t.length;i<a;i++)t[i].updateMatrixWorld(e)}updateWorldMatrix(e,t){var i=this.parent;if(!0===e&&null!==i&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.multiplyMatrices(this.mLocalTransform,this.matrix):(this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.mLocalTransform),this.matrixWorld.multiplyMatrices(this.matrixWorld,this.matrix)),!0===t)for(var a=this.children,r=0,s=a.length;r<s;r++)a[r].updateWorldMatrix(!1,!0)}}class SpeLayer{constructor(e,t=SPE_LAYER_TYPE_COLOR,i={}){this.mId=e,this.mType=t,this.mNext=null,this.mDefines={},this.mUniforms={},this.mProgramVertUniforms="",this.mProgramFragUniforms="",this.initializeUniformsAndDefines(i)}get id(){return this.mId}get type(){return this.mType}get next(){return this.mNext}set next(e){this.mNext=e}get defines(){return this.mDefines}get uniforms(){return this.mUniforms}get paramNames(){const e=Object.keys(this.mUniforms),t=`f${this.mId}_`,i=[];for(let a=0;a<e.length;a++){const r=e[a];i.push(r.slice(r.indexOf(t)+t.length))}return i}getValues(){const e=`f${this.mId}_`,t={type:this.type};for(const[i,a]of Object.entries(this.mUniforms)){const r=i.slice(i.indexOf(e)+e.length);a.value.toArray?t[r]=a.value.toArray():t[r]=a.value}return t}initializeUniformsAndDefines(e){console.error("SpeLayer::initializeUniformsAndDefines >>> virtual method")}generateUniformsCodeVert(){return"\n\r"}generateUniformsCodeFrag(){return"\n\r"}generateShaderCodeVert(e){return"\n\r"}generateShaderCodeFrag(e){return"\n\r"}copy(e){this.mType===e.mType?(this.mId=e.mId,this.mDefines={...e.mDefines},this.copyUniforms(e)):console.error(`SpeLayer::copy >>> cant copy layer of different type dst=${this.mType}, src=${e.mType}`)}clone(){return SpeLayer.CreateLayer(this.mId,this.mType,this.mUniforms)}copyUniforms(e){console.error("SpeLayer::copyUniforms >>> virtual method")}static CreateLayer(e,t,i){return t===SPE_LAYER_TYPE_LIGHTING?new SpeLayerLighting(e,i):t===SPE_LAYER_TYPE_COLOR?new SpeLayerColor(e,i):t===SPE_LAYER_TYPE_GRADIENT?new SpeLayerGradient(e,i):t===SPE_LAYER_TYPE_NORMAL?new SpeLayerNormal(e,i):t===SPE_LAYER_TYPE_DEPTH?new SpeLayerDepth(e,i):t===SPE_LAYER_TYPE_TEXTURE?new SpeLayerTexture(e,i):t===SPE_LAYER_TYPE_NOISE?new SpeLayerNoise(e,i):t===SPE_LAYER_TYPE_FRESNEL?new SpeLayerFresnel(e,i):t===SPE_LAYER_TYPE_POINTS?new SpeLayerPoints(e,i):t===SPE_LAYER_TYPE_LINES?new SpeLayerLines(e,i):null}static DictToUniforms(e){const t={};for(const[i,a]of Object.entries(e))t[i]={value:a};return t}}class SpeLayerLighting extends SpeLayer{constructor(e,t){super(e,SPE_LAYER_TYPE_LIGHTING,t)}initializeUniformsAndDefines(e){this.mDefines.SPE_USE_LAYER_LIGHTING="",this.mUniforms[`f${this.mId}_alpha`]={value:void 0!==e.alpha?e.alpha.value:1},this.mUniforms[`f${this.mId}_mode`]={value:void 0!==e.mode?e.mode.value:SPE_BLENDING_NORMAL}}generateUniformsCodeFrag(){return`\n            // SPE: Lighting layer uniforms *****\n            uniform float f${this.mId}_alpha;\n            uniform int f${this.mId}_mode;\n            // **********************************\n        `}generateShaderCodeFrag(){return`\n            // SPE: Lighting layer frag-shader-code ************************************************\n            // @todo: instead of == use absolute distance for vector comparison\n            if ( outgoingLight != diffuseColor.rgb ) {\n                float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );\n                accumAlpha += ( 1.0 - accumAlpha ) * f${this.mId}_alpha * lightAccu;\n                outgoingLight = spe_blend( diffuseColor.rgb, outgoingLight, f${this.mId}_alpha, f${this.mId}_mode );\n            }\n            // *************************************************************************************\n        `}copyUniforms(e){e instanceof SpeLayerLighting&&(this.mUniforms[`f${this.mId}_alpha`]={value:e.uniforms[`f${e.id}_alpha`].value},this.mUniforms[`f${this.mId}_mode`]={value:e.uniforms[`f${e.id}_mode`].value})}}class SpeLayerColor extends SpeLayer{constructor(e,t){super(e,SPE_LAYER_TYPE_COLOR,t)}initializeUniformsAndDefines(e){this.mDefines.SPE_USE_LAYER_COLOR="",this.mUniforms[`f${this.mId}_alpha`]={value:void 0!==e.alpha?e.alpha.value:1},this.mUniforms[`f${this.mId}_mode`]={value:void 0!==e.mode?e.mode.value:SPE_BLENDING_NORMAL},this.mUniforms[`f${this.mId}_color`]={value:void 0!==e.color?new THREE.Color(e.color.value):new THREE.Color(SPE_COLOR_DEFAULT)}}generateUniformsCodeFrag(){return`\n            // SPE: Color layer uniforms **********\n            uniform float f${this.mId}_alpha;\n            uniform int f${this.mId}_mode;\n            uniform vec3 f${this.mId}_color;\n            // ************************************\n        `}generateShaderCodeFrag(e){return`\n            // SPE: Color layer frag-shader-code ***************************************************\n            float f${this.mId}_calpha = f${this.mId}_alpha / clamp( f${this.mId}_alpha + accumAlpha, 0.00001, 1.0 );\n            accumAlpha += ( 1.0 - accumAlpha ) * f${this.mId}_alpha;\n            ${e} = spe_blend( ${e}, f${this.mId}_color, f${this.mId}_calpha, f${this.mId}_mode );\n            // *************************************************************************************\n        `}copyUniforms(e){e instanceof SpeLayerColor&&(this.mUniforms[`f${this.mId}_alpha`]={value:e.uniforms[`f${e.id}_alpha`].value},this.mUniforms[`f${this.mId}_mode`]={value:e.uniforms[`f${e.id}_mode`].value},this.mUniforms[`f${this.mId}_color`]={value:e.uniforms[`f${e.id}_color`].value.clone()})}}class SpeLayerTexture extends SpeLayer{constructor(e,t){super(e,SPE_LAYER_TYPE_TEXTURE,t)}initializeUniformsAndDefines(e){var t;this.mDefines.SPE_USE_LAYER_TEXTURE="",this.mDefines.USE_UV="",this.mUniforms[`f${this.mId}_alpha`]={value:void 0!==e.alpha?e.alpha.value:1},this.mUniforms[`f${this.mId}_mode`]={value:void 0!==e.mode?e.mode.value:SPE_BLENDING_NORMAL},this.mUniforms[`f${this.mId}_texture`]={value:void 0!==e.texture?(t=e.texture.value,t instanceof THREE.Texture?t:"string"==typeof t?function(e){const t=new Image;t.src=e;const i=new THREE.Texture(t);return i.needsUpdate=!0,i}(t):(console.error("SpeLayerTexture::get_texture >>> cant retrieve texture from given parameters"),new THREE.Texture)):new THREE.Texture},this.mUniforms[`f${this.mId}_mat`]={value:void 0!==e.mat?this.mUniforms[`f${this.mId}_texture`].value.matrix.fromArray(void 0!==e.mat.value.elements?e.mat.value.elements:e.mat.value):this.mUniforms[`f${this.mId}_texture`].value.matrix},this.mUniforms[`f${this.mId}_crop`]={value:void 0!==e.crop?e.crop.value:0}}generateUniformsCodeFrag(){return`\n            // SPE: Texture layer uniforms ********\n            uniform float f${this.mId}_alpha;\n            uniform int f${this.mId}_mode;\n            uniform sampler2D f${this.mId}_texture;\n            uniform mat3 f${this.mId}_mat;\n            uniform float f${this.mId}_crop;\n            // ************************************\n        `}generateShaderCodeFrag(e){return`\n            // SPE: Texture layer frag-shader-code *************************************************\n            vec2 f${this.mId}_vUv = ( f${this.mId}_mat * vec3( vUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;\n            vec4 f${this.mId}_tmp = texture2D( f${this.mId}_texture, f${this.mId}_vUv );\n            vec3 f${this.mId}_col = f${this.mId}_tmp.rgb;\n            float f${this.mId}_lalpha = f${this.mId}_alpha * f${this.mId}_tmp.a;\n            if ( f${this.mId}_crop > 0.5 ) {\n                if ( f${this.mId}_vUv.x < 0.0 || f${this.mId}_vUv.x > 1.0 ||\n                     f${this.mId}_vUv.y < 0.0 || f${this.mId}_vUv.y > 1.0 ) {\n                        f${this.mId}_lalpha = 0.0;\n                }\n            }\n            float f${this.mId}_calpha =  f${this.mId}_lalpha / clamp( f${this.mId}_lalpha + accumAlpha, 0.00001, 1.0 );\n            accumAlpha += ( 1.0 - accumAlpha ) * f${this.mId}_lalpha;\n            ${e} = spe_blend( ${e}, f${this.mId}_col, f${this.mId}_calpha, f${this.mId}_mode );\n            // *************************************************************************************\n        `}copyUniforms(e){e instanceof SpeLayerTexture&&(this.mUniforms[`f${this.mId}_alpha`]={value:e.uniforms[`f${e.id}_alpha`].value},this.mUniforms[`f${this.mId}_mode`]={value:e.uniforms[`f${e.id}_mode`].value},this.mUniforms[`f${this.mId}_texture`]={value:e.uniforms[`f${e.id}_texture`].value.clone()},this.mUniforms[`f${this.mId}_mat`]={value:this.mUniforms[`f${this.mId}_texture`].value.matrix},this.mUniforms[`f${this.mId}_crop`]={value:e.uniforms[`f${e.id}_crop`].value})}static DictToUniforms(e){return{alpha:{value:e.alpha},mode:{value:e.mode},texture:{value:e.texture},mat:{value:e.texture.matrix},crop:{value:e.crop}}}}class SpeLayerNormal extends SpeLayer{constructor(e,t){super(e,SPE_LAYER_TYPE_NORMAL,t)}initializeUniformsAndDefines(e){this.mDefines.SPE_USE_LAYER_NORMAL="",this.mUniforms[`f${this.mId}_alpha`]={value:void 0!==e.alpha?e.alpha.value:1},this.mUniforms[`f${this.mId}_mode`]={value:void 0!==e.mode?e.mode.value:SPE_BLENDING_NORMAL},this.mUniforms[`f${this.mId}_cnormal`]={value:void 0!==e.cnormal?(new THREE.Vector3).fromArray(e.cnormal.value):new THREE.Vector3(1,1,1)}}generateUniformsCodeFrag(){return`\n            // SPE: Normal layer uniforms ********\n            uniform float f${this.mId}_alpha;\n            uniform int f${this.mId}_mode;\n            uniform vec3 f${this.mId}_cnormal;\n            // ***********************************\n        `}generateShaderCodeFrag(e){return`\n            // SPE: Normal layer frag-shader-code **************************************************\n            vec3 f${this.mId}_normal = packNormalToRGB( normal ).rgb;\n            f${this.mId}_normal *= step( vec3(0.5), f${this.mId}_cnormal );\n            float f${this.mId}_calpha = f${this.mId}_alpha / clamp( f${this.mId}_alpha + accumAlpha, 0.00001, 1.0 );\n            accumAlpha += ( 1.0 - accumAlpha ) * f${this.mId}_alpha;\n            ${e} = spe_blend( ${e}, f${this.mId}_normal, f${this.mId}_calpha, f${this.mId}_mode );\n            // *************************************************************************************\n        `}copyUniforms(e){e instanceof SpeLayerNormal&&(this.mUniforms[`f${this.mId}_alpha`]={value:e.uniforms[`f${e.id}_alpha`].value},this.mUniforms[`f${this.mId}_mode`]={value:e.uniforms[`f${e.id}_mode`].value},this.mUniforms[`f${this.mId}_cnormal`]={value:e.uniforms[`f${e.id}_cnormal`].value.clone()})}}class SpeLayerDepth extends SpeLayer{constructor(e,t){super(e,SPE_LAYER_TYPE_DEPTH,t)}initializeUniformsAndDefines(e){this.mDefines.SPE_USE_LAYER_DEPTH="",this.mUniforms[`f${this.mId}_alpha`]={value:void 0!==e.alpha?e.alpha.value:1},this.mUniforms[`f${this.mId}_mode`]={value:void 0!==e.mode?e.mode.value:SPE_BLENDING_NORMAL},this.mUniforms[`f${this.mId}_near`]={value:void 0!==e.near?e.near.value:700},this.mUniforms[`f${this.mId}_far`]={value:void 0!==e.far?e.far.value:1e3},this.mUniforms[`f${this.mId}_origin`]={value:void 0!==e.origin?(new THREE.Vector3).fromArray(e.origin.value):new THREE.Vector3},this.mUniforms[`f${this.mId}_isVector`]={value:void 0!==e.isVector?e.isVector.value:0},this.mUniforms[`f${this.mId}_colorA`]={value:e.colorA?new THREE.Color(e.colorA.value):new THREE.Color},this.mUniforms[`f${this.mId}_colorB`]={value:e.colorB?new THREE.Color(e.colorB.value):new THREE.Color(0,0,0)}}generateUniformsCodeFrag(){return`\n            // SPE: Depth layer uniforms *************\n            uniform float f${this.mId}_alpha;\n            uniform int f${this.mId}_mode;\n            uniform float f${this.mId}_near;\n            uniform float f${this.mId}_far;\n            uniform float f${this.mId}_isVector;\n            uniform vec3 f${this.mId}_origin;\n            uniform vec3 f${this.mId}_colorA;\n            uniform vec3 f${this.mId}_colorB;\n            // ***************************************\n        `}generateShaderCodeFrag(e){return`\n            // SPE: Depth layer frag-shader-code ***************************************************\n            vec3 base${this.mId} = ( f${this.mId}_isVector > 0.5 ) ?  f${this.mId}_origin : cameraPosition;\n            float dist${this.mId} = length( dWorldPosition.xyz - base${this.mId} );\n            float dep${this.mId} = ( dist${this.mId} - f${this.mId}_near ) / ( f${this.mId}_far - f${this.mId}_near );\n            vec3 f${this.mId}_depth =  mix( f${this.mId}_colorB, f${this.mId}_colorA, 1.0 - clamp( dep${this.mId}, 0., 1. ) );\n            float f${this.mId}_calpha = f${this.mId}_alpha / clamp( f${this.mId}_alpha + accumAlpha, 0.001, 1.0 );\n            accumAlpha += ( 1.0 - accumAlpha ) * f${this.mId}_alpha;\n            ${e} = spe_blend( ${e}, f${this.mId}_depth, f${this.mId}_calpha, f${this.mId}_mode );\n            // *************************************************************************************\n        `}copyUniforms(e){e instanceof SpeLayerDepth&&(this.mUniforms[`f${this.mId}_alpha`]={value:e.uniforms[`f${e.id}_alpha`].value},this.mUniforms[`f${this.mId}_mode`]={value:e.uniforms[`f${e.id}_mode`].value},this.mUniforms[`f${this.mId}_near`]={value:e.uniforms[`f${e.id}_near`].value},this.mUniforms[`f${this.mId}_far`]={value:e.uniforms[`f${e.id}_far`].value},this.mUniforms[`f${this.mId}_origin`]={value:e.uniforms[`f${e.id}_origin`].value.clone()},this.mUniforms[`f${this.mId}_isVector`]={value:e.uniforms[`f${e.id}_isVector`].value},this.mUniforms[`f${this.mId}_colorA`]={value:e.uniforms[`f${e.id}_colorA`].value.clone()},this.mUniforms[`f${this.mId}_colorB`]={value:e.uniforms[`f${e.id}_colorB`].value.clone()})}}class SpeLayerNoise extends SpeLayer{constructor(e,t){super(e,SPE_LAYER_TYPE_NOISE,t)}initializeUniformsAndDefines(e){this.mDefines.SPE_USE_LAYER_NOISE="",this.mDefines.SPE_USE_LAYER_TEXTURE="",this.mDefines.SPE_NOISE_NUM_OCTAVES="5",this.mDefines.USE_UV="",this.mUniforms[`f${this.mId}_alpha`]={value:void 0!==e.alpha?e.alpha.value:1},this.mUniforms[`f${this.mId}_mode`]={value:void 0!==e.mode?e.mode.value:SPE_BLENDING_NORMAL},this.mUniforms[`f${this.mId}_scale`]={value:void 0!==e.scale?e.scale.value:2},this.mUniforms[`f${this.mId}_move`]={value:void 0!==e.move?e.move.value:1},this.mUniforms[`f${this.mId}_distortion`]={value:void 0!==e.distortion?(new THREE.Vector2).fromArray(e.distortion.value):new THREE.Vector2(1,1)},this.mUniforms[`f${this.mId}_fA`]={value:void 0!==e.fA?(new THREE.Vector2).fromArray(e.fA.value):new THREE.Vector2(1.7,9.2)},this.mUniforms[`f${this.mId}_fB`]={value:void 0!==e.fB?(new THREE.Vector2).fromArray(e.fB.value):new THREE.Vector2(8.3,2.8)},this.mUniforms[`f${this.mId}_colorA`]={value:void 0!==e.colorA?new THREE.Color(e.colorA.value):new THREE.Color(.4,.4,.4)},this.mUniforms[`f${this.mId}_colorB`]={value:void 0!==e.colorB?new THREE.Color(e.colorB.value):new THREE.Color(.4,.4,.4)},this.mUniforms[`f${this.mId}_colorC`]={value:void 0!==e.colorC?new THREE.Color(e.colorC.value):new THREE.Color(1,1,1)},this.mUniforms[`f${this.mId}_colorD`]={value:void 0!==e.colorD?new THREE.Color(e.colorD.value):new THREE.Color(1,1,1)},this.mUniforms[`f${this.mId}_intA`]={value:void 0!==e.intA?e.intA.value:10},this.mUniforms[`f${this.mId}_intB`]={value:void 0!==e.intB?e.intB.value:10},this.mUniforms[`f${this.mId}_intC`]={value:void 0!==e.intC?e.intC.value:10},this.mUniforms[`f${this.mId}_intD`]={value:void 0!==e.intD?e.intD.value:10}}generateUniformsCodeFrag(){return`\n            // SPE: Noise layer uniforms *******************\n            uniform float f${this.mId}_alpha;\n            uniform int f${this.mId}_mode;\n            uniform float f${this.mId}_scale;\n            uniform float f${this.mId}_move;\n            uniform vec2 f${this.mId}_fA;\n            uniform vec2 f${this.mId}_fB;\n            uniform vec2 f${this.mId}_distortion;\n            uniform vec3 f${this.mId}_colorA;\n            uniform vec3 f${this.mId}_colorB;\n            uniform vec3 f${this.mId}_colorC;\n            uniform vec3 f${this.mId}_colorD;\n            uniform float f${this.mId}_intA;\n            uniform float f${this.mId}_intB;\n            uniform float f${this.mId}_intC;\n            uniform float f${this.mId}_intD;\n            // *********************************************\n        `}generateShaderCodeFrag(e){return`\n            // SPE: Noise layer frag-shader-code ***************************************************\n            vec2 f${this.mId}_st = vUv * f${this.mId}_scale;\n            vec3 f${this.mId}_color;\n            vec2 f${this.mId}_q = vec2( fbm( f${this.mId}_st ), fbm( f${this.mId}_st + vec2(1.0) ) );\n            vec2 f${this.mId}_r = vec2( fbm( f${this.mId}_st + f${this.mId}_distortion * f${this.mId}_q + f${this.mId}_fA + f${this.mId}_move ),\n                                        fbm( f${this.mId}_st + f${this.mId}_distortion * f${this.mId}_q + f${this.mId}_fB + f${this.mId}_move ) );\n            float f${this.mId}_f = fbm( f${this.mId}_st + f${this.mId}_r );\n            f${this.mId}_color = mix( f${this.mId}_colorA * f${this.mId}_intA, f${this.mId}_colorB * f${this.mId}_intB,\n                         clamp((f${this.mId}_f*f${this.mId}_f)*4.0,0.0,1.0) );\n            f${this.mId}_color = mix( f${this.mId}_color, f${this.mId}_colorC * f${this.mId}_intC,\n                         clamp( length(f${this.mId}_q), 0.0, 1.0 ) );\n            f${this.mId}_color = mix( f${this.mId}_color, f${this.mId}_colorD * f${this.mId}_intD,\n                         clamp( length(f${this.mId}_r.x), 0.0, 1.0 ) );\n            vec3 f${this.mId}_noise = clamp( vec3( f${this.mId}_f * f${this.mId}_color ), 0.0, 1.0 );\n            float f${this.mId}_calpha = f${this.mId}_alpha / clamp( f${this.mId}_alpha + accumAlpha, 0.001, 1.0 );\n            accumAlpha += ( 1.0 - accumAlpha ) * f${this.mId}_alpha;\n            ${e} = spe_blend( ${e}, f${this.mId}_noise, f${this.mId}_calpha, f${this.mId}_mode );\n            // *************************************************************************************\n        `}copyUniforms(e){e instanceof SpeLayerNoise&&(this.mUniforms[`f${this.mId}_alpha`]={value:e.uniforms[`f${e.id}_alpha`].value},this.mUniforms[`f${this.mId}_mode`]={value:e.uniforms[`f${e.id}_mode`].value},this.mUniforms[`f${this.mId}_scale`]={value:e.uniforms[`f${e.id}_scale`].value},this.mUniforms[`f${this.mId}_move`]={value:e.uniforms[`f${e.id}_move`].value},this.mUniforms[`f${this.mId}_distortion`]={value:e.uniforms[`f${e.id}_distortion`].value.clone()},this.mUniforms[`f${this.mId}_fA`]={value:e.uniforms[`f${e.id}_fA`].value.clone()},this.mUniforms[`f${this.mId}_fB`]={value:e.uniforms[`f${e.id}_fB`].value.clone()},this.mUniforms[`f${this.mId}_colorA`]={value:e.uniforms[`f${e.id}_colorA`].value.clone()},this.mUniforms[`f${this.mId}_colorB`]={value:e.uniforms[`f${e.id}_colorB`].value.clone()},this.mUniforms[`f${this.mId}_colorC`]={value:e.uniforms[`f${e.id}_colorC`].value.clone()},this.mUniforms[`f${this.mId}_colorD`]={value:e.uniforms[`f${e.id}_colorD`].value.clone()},this.mUniforms[`f${this.mId}_intA`]={value:e.uniforms[`f${e.id}_intA`].value},this.mUniforms[`f${this.mId}_intB`]={value:e.uniforms[`f${e.id}_intB`].value},this.mUniforms[`f${this.mId}_intC`]={value:e.uniforms[`f${e.id}_intC`].value},this.mUniforms[`f${this.mId}_intD`]={value:e.uniforms[`f${e.id}_intD`].value})}}class SpeLayerFresnel extends SpeLayer{constructor(e,t){super(e,SPE_LAYER_TYPE_FRESNEL,t)}initializeUniformsAndDefines(e){this.mDefines.SPE_USE_LAYER_FRESNEL="",this.mUniforms[`f${this.mId}_alpha`]={value:void 0!==e.alpha?e.alpha.value:1},this.mUniforms[`f${this.mId}_mode`]={value:void 0!==e.mode?e.mode.value:SPE_BLENDING_NORMAL},this.mUniforms[`f${this.mId}_bias`]={value:void 0!==e.bias?e.bias.value:.1},this.mUniforms[`f${this.mId}_scale`]={value:void 0!==e.scale?e.scale.value:1},this.mUniforms[`f${this.mId}_intensity`]={value:void 0!==e.intensity?e.intensity.value:2},this.mUniforms[`f${this.mId}_factor`]={value:void 0!==e.factor?e.factor.value:1},this.mUniforms[`f${this.mId}_color`]={value:void 0!==e.color?new THREE.Color(e.color.value):new THREE.Color}}generateUniformsCodeFrag(){return`\n            // SPE: Fresnel layer uniforms *********\n            uniform float f${this.mId}_alpha;\n            uniform int f${this.mId}_mode;\n            uniform float f${this.mId}_bias;\n            uniform float f${this.mId}_scale;\n            uniform float f${this.mId}_intensity;\n            uniform float f${this.mId}_factor;\n            uniform vec3 f${this.mId}_color;\n            // *************************************\n        `}generateShaderCodeFrag(e){return`\n            // SPE: Fresnel layer frag-shader-code *************************************************\n            float f${this.mId}_fresnel = f${this.mId}_bias + f${this.mId}_scale * pow( f${this.mId}_factor + dot( normalize( vWorldViewDir ), normalize( vWorldNormal ) ), f${this.mId}_intensity );\n            float f${this.mId}_lalpha = clamp( f${this.mId}_fresnel, 0.0, 1.0 ) * f${this.mId}_alpha;\n            float f${this.mId}_calpha = f${this.mId}_lalpha / clamp( f${this.mId}_lalpha + accumAlpha, 0.001, 1.0 );\n            accumAlpha += ( 1.0 - accumAlpha ) * f${this.mId}_lalpha;\n            ${e} = spe_blend( ${e}, f${this.mId}_color, f${this.mId}_calpha, f${this.mId}_mode );\n            // *************************************************************************************\n        `}copyUniforms(e){e instanceof SpeLayerFresnel&&(this.mUniforms[`f${this.mId}_alpha`]={value:e.uniforms[`f${e.id}_alpha`].value},this.mUniforms[`f${this.mId}_mode`]={value:e.uniforms[`f${e.id}_mode`].value},this.mUniforms[`f${this.mId}_bias`]={value:e.uniforms[`f${e.id}_bias`].value},this.mUniforms[`f${this.mId}_scale`]={value:e.uniforms[`f${e.id}_scale`].value},this.mUniforms[`f${this.mId}_intensity`]={value:e.uniforms[`f${e.id}_intensity`].value},this.mUniforms[`f${this.mId}_factor`]={value:e.uniforms[`f${e.id}_factor`].value},this.mUniforms[`f${this.mId}_color`]={value:e.uniforms[`f${e.id}_color`].value.clone()})}}class SpeLayerGradient extends SpeLayer{constructor(e,t){super(e,SPE_LAYER_TYPE_GRADIENT,t)}initializeUniformsAndDefines(e){this.mDefines.SPE_USE_LAYER_GRADIENT="",this.mDefines.SPE_GRADIENT_MAX_SIZE="10",this.mDefines.USE_UV="",this.mUniforms[`f${this.mId}_alpha`]={value:void 0!==e.alpha?e.alpha.value:1},this.mUniforms[`f${this.mId}_mode`]={value:void 0!==e.mode?e.mode.value:SPE_BLENDING_NORMAL},this.mUniforms[`f${this.mId}_gl_type`]={value:void 0!==e.gl_type?e.gl_type.value:0},this.mUniforms[`f${this.mId}_num`]={value:void 0!==e.num?e.num.value:2},this.mUniforms[`f${this.mId}_smooth`]={value:void 0!==e.smooth&&e.smooth.value},this.mUniforms[`f${this.mId}_colors`]={value:function(e){const t=[];for(let i=0;i<Math.floor(e.length/4);i++)t.push(new THREE.Vector4(e[4*i+0],e[4*i+1],e[4*i+2],e[4*i+3]));return t}(void 0!==e.colors?e.colors.value:new Array(40).fill())},this.mUniforms[`f${this.mId}_steps`]={value:void 0!==e.steps?e.steps.value:new Array(10).fill()},this.mUniforms[`f${this.mId}_offset`]={value:void 0!==e.offset?(new THREE.Vector2).fromArray(e.offset.value):new THREE.Vector2(0,0)},this.mUniforms[`f${this.mId}_morph`]={value:void 0!==e.morph?(new THREE.Vector2).fromArray(e.morph.value):new THREE.Vector2(0,0)},this.mUniforms[`f${this.mId}_angle`]={value:void 0!==e.angle?e.angle.value:0}}generateUniformsCodeFrag(){return`\n            // SPE: Gradient layer uniforms ****************\n            uniform float f${this.mId}_alpha;\n            uniform int f${this.mId}_mode;\n            uniform int f${this.mId}_gl_type;\n            uniform int f${this.mId}_num;\n            uniform bool f${this.mId}_smooth;\n            uniform vec4 f${this.mId}_colors[SPE_GRADIENT_MAX_SIZE];\n            uniform float f${this.mId}_steps[SPE_GRADIENT_MAX_SIZE];\n            uniform vec2 f${this.mId}_offset;\n            uniform vec2 f${this.mId}_morph;\n            uniform float f${this.mId}_angle;\n            // *********************************************\n        `}generateShaderCodeFrag(e){return`\n            // SPE: Gradient layer frag-shader-code ************************************************\n            vec4 f${this.mId}_color = f${this.mId}_colors[0];\n            vec2 f${this.mId}_m = f${this.mId}_morph / vUv.xy;\n            vec2 f${this.mId}_rot = vec2( 0.5 + f${this.mId}_m.x, f${this.mId}_m.y );\n            vec2 f${this.mId}_dt = vec2(\n                cos( f${this.mId}_angle ) * f${this.mId}_rot.x - sin( f${this.mId}_angle ) * f${this.mId}_rot.y,\n                sin( f${this.mId}_angle ) * f${this.mId}_rot.x + cos( f${this.mId}_angle ) * f${this.mId}_rot.y\n            );\n            vec2 f${this.mId}_pt = ( vUv - 0.5 + f${this.mId}_offset ) / 2.0 + f${this.mId}_dt / 2.0;\n            float f${this.mId}_t = dot( f${this.mId}_pt, f${this.mId}_dt ) / dot( f${this.mId}_dt, f${this.mId}_dt );\n            if ( f${this.mId}_gl_type == 1 ) {\n                f${this.mId}_t = distance (\n                    ( vUv + f${this.mId}_morph ) * 3.0,\n                    ( vUv + f${this.mId}_offset ) + 1.0\n                ) + f${this.mId}_angle;\n            } else if ( f${this.mId}_gl_type == 2 ) {\n                float f${this.mId}_polar = atan(\n                    vUv.x + f${this.mId}_morph.x - 0.5 + f${this.mId}_offset.x,\n                    vUv.y + f${this.mId}_morph.y - 0.5 + f${this.mId}_offset.y\n                ) * -1.0;\n                f${this.mId}_t = fract( ( f${this.mId}_angle / PI / -2.0 ) + 0.5 * ( f${this.mId}_polar / PI ) );\n            }\n            float f${this.mId}_p;\n            for ( int i = 1; i < SPE_GRADIENT_MAX_SIZE; i++ ) {\n                if ( i < f${this.mId}_num ) {\n                    f${this.mId}_p = clamp( ( f${this.mId}_t - f${this.mId}_steps[i-1] ) / ( f${this.mId}_steps[i] - f${this.mId}_steps[i-1] ), 0.0, 1.0 );\n                    f${this.mId}_color = mix( f${this.mId}_color, f${this.mId}_colors[i],\n                        ( f${this.mId}_smooth ) ? smoothstep( 0.0, 1.0, f${this.mId}_p ) : f${this.mId}_p\n                    );\n                } else {\n                    break;\n                }\n            }\n            float f${this.mId}_lalpha = f${this.mId}_alpha * f${this.mId}_color.a;\n            float f${this.mId}_calpha =  f${this.mId}_lalpha / clamp( f${this.mId}_lalpha + accumAlpha, 0.00001, 1.0 );\n            accumAlpha += ( 1.0 - accumAlpha ) * f${this.mId}_lalpha;\n            ${e} = spe_blend( ${e}, f${this.mId}_color.xyz, f${this.mId}_calpha, f${this.mId}_mode );\n            // *************************************************************************************\n        `}getValues(){const e={type:this.type};return e.alpha=this.mUniforms[`f${this.mId}_alpha`].value,e.mode=this.mUniforms[`f${this.mId}_mode`].value,e.gl_type=this.mUniforms[`f${this.mId}_gl_type`].value,e.num=this.mUniforms[`f${this.mId}_num`].value,e.smooth=this.mUniforms[`f${this.mId}_smooth`].value,e.colors=function(e){const t=[];for(let i=0;i<e.length;i++)t.push(e[i].x,e[i].y,e[i].z,e[i].w);return t}(this.mUniforms[`f${this.mId}_colors`].value),e.steps=[].concat(this.mUniforms[`f${this.mId}_steps`].value),e.offset=this.mUniforms[`f${this.mId}_offset`].value.toArray(),e.morph=this.mUniforms[`f${this.mId}_morph`].value.toArray(),e.angle=this.mUniforms[`f${this.mId}_angle`].value,e}copyUniforms(e){e instanceof SpeLayerGradient&&(this.mUniforms[`f${this.mId}_alpha`]={value:e.uniforms[`f${e.id}_alpha`].value},this.mUniforms[`f${this.mId}_mode`]={value:e.uniforms[`f${e.id}_mode`].value},this.mUniforms[`f${this.mId}_gl_type`]={value:e.uniforms[`f${e.id}_gl_type`].value},this.mUniforms[`f${this.mId}_num`]={value:e.uniforms[`f${e.id}_num`].value},this.mUniforms[`f${this.mId}_smooth`]={value:e.uniforms[`f${e.id}_smooth`].value},this.mUniforms[`f${this.mId}_colors`]={value:function(e){const t=[];for(let i=0;i<e.length;i++)t.push(e[i].clone());return t}(e.uniforms[`f${e.id}_colors`].value)},this.mUniforms[`f${this.mId}_steps`]={value:[].concat(e.uniforms[`f${e.id}_steps`].value)},this.mUniforms[`f${this.mId}_offset`]={value:e.uniforms[`f${e.id}_offset`].value.clone()},this.mUniforms[`f${this.mId}_morph`]={value:e.uniforms[`f${e.id}_morph`].value.clone()},this.mUniforms[`f${this.mId}_angle`]={value:e.uniforms[`f${e.id}_angle`].value})}}class SpeLayerPoints extends SpeLayer{constructor(e,t){super(e,SPE_LAYER_TYPE_POINTS,t)}initializeUniformsAndDefines(e){this.mDefines.SPE_USE_LAYER_POINTS="",this.mUniforms[`f${this.mId}_alpha`]={value:void 0!==e.alpha?e.alpha.value:1},this.mUniforms[`f${this.mId}_mode`]={value:void 0!==e.mode?e.mode.value:SPE_BLENDING_NORMAL},this.mUniforms[`f${this.mId}_color`]={value:void 0!==e.color?new THREE.Color(e.color.value):new THREE.Color(12237498)},this.mUniforms[`f${this.mId}_useBack`]={value:void 0===e.useBack||e.useBack.value},this.mUniforms[`f${this.mId}_threshold`]={value:void 0!==e.threshold?e.threshold.value:.9}}generateUniformsCodeFrag(){return`\n            // SPE: Points layer uniforms **************\n            uniform float f${this.mId}_alpha;\n            uniform int f${this.mId}_mode;\n            uniform vec3 f${this.mId}_color;\n            uniform bool f${this.mId}_useBack;\n            uniform float f${this.mId}_threshold;\n            // *****************************************\n        `}generateShaderCodeFrag(e){return`\n            // SPE: Points layer frag-shader-code **************************************************\n            float f${this.mId}_dist = length( vBarycentric );\n            float f${this.mId}_edge = aastep( f${this.mId}_threshold, f${this.mId}_dist, 0.00 );\n            float f${this.mId}_factor = gl_FrontFacing ? 1.0 : ( f${this.mId}_useBack ? 0.5 : 0.0 );\n            accumAlpha += ( 1.0 - accumAlpha ) * f${this.mId}_alpha * f${this.mId}_edge;\n            ${e} = spe_blend( ${e}, f${this.mId}_factor * f${this.mId}_color, f${this.mId}_alpha * f${this.mId}_edge, f${this.mId}_mode );\n            // *************************************************************************************\n        `}}class SpeLayerLines extends SpeLayer{constructor(e,t){super(e,SPE_LAYER_TYPE_LINES,t)}initializeUniformsAndDefines(e){this.mDefines.SPE_USE_LAYER_LINES="",this.mUniforms[`f${this.mId}_alpha`]={value:void 0!==e.alpha?e.alpha.value:1},this.mUniforms[`f${this.mId}_mode`]={value:void 0!==e.mode?e.mode.value:SPE_BLENDING_NORMAL},this.mUniforms[`f${this.mId}_color`]={value:void 0!==e.color?new THREE.Color(e.color.value):new THREE.Color(12237498)},this.mUniforms[`f${this.mId}_thickness`]={value:void 0!==e.thickness?e.thickness.value:.01},this.mUniforms[`f${this.mId}_useBack`]={value:void 0===e.useBack||e.useBack.value},this.mUniforms[`f${this.mId}_smoothOffset`]={value:void 0!==e.smoothOffset?e.smoothOffset.value:.03}}generateUniformsCodeFrag(){return`\n            // SPE: Lines layer uniforms *************************\n            uniform float f${this.mId}_alpha;\n            uniform int f${this.mId}_mode;\n            uniform vec3 f${this.mId}_color;\n            uniform float f${this.mId}_thickness;\n            uniform bool f${this.mId}_useBack;\n            uniform float f${this.mId}_smoothOffset;\n            // **************************************************\n        `}generateShaderCodeFrag(e){return`\n            // SPE: Lines layer frag-shader-code ***************************************************\n            float f${this.mId}_dist = min( vBarycentric.x, min( vBarycentric.y, vBarycentric.z ) );\n            float f${this.mId}_comp_thickness = f${this.mId}_thickness;\n            float f${this.mId}_edge = 1.0 - aastep( f${this.mId}_comp_thickness, f${this.mId}_dist, f${this.mId}_smoothOffset );\n            float f${this.mId}_factor = gl_FrontFacing ? 1.0 : ( f${this.mId}_useBack ? 0.5 : 0.0 );\n            accumAlpha += ( 1.0 - accumAlpha ) * f${this.mId}_alpha * f${this.mId}_edge;\n            ${e} = spe_blend( ${e}, f${this.mId}_factor * f${this.mId}_color, f${this.mId}_alpha * f${this.mId}_edge, f${this.mId}_mode );\n            // *************************************************************************************\n        `}}if(!SPE.CreateLayerFromJSON){function preprocess_uniforms(e,t){const i={},a=`f${e}_`;for(const e in t){const r=e.slice(e.indexOf(a)+a.length),s=t[e].value;if("boolean"==typeof s)i[r]={name:r,value:s,type:SPE_LAYER_UNIFORM_TYPE_BOOL};else if("number"==typeof s)Number.isInteger(s)?i[r]={name:r,value:s,type:SPE_LAYER_UNIFORM_TYPE_INT}:i[r]={name:r,value:s,type:SPE_LAYER_UNIFORM_TYPE_FLOAT};else if("string"!=typeof s||isNaN(s))if(s instanceof Object&&2===Object.entries(s).length)void 0!==s.x&&void 0!==s.y&&(i[r]={name:r,value:[s.x,s.y],type:SPE_LAYER_UNIFORM_TYPE_VEC2});else if(s instanceof Object&&3===Object.entries(s).length)void 0!==s.x&&void 0!==s.y&&void 0!==s.z&&(i[r]={name:r,value:[s.x,s.y,s.z],type:SPE_LAYER_UNIFORM_TYPE_VEC3});else if(s instanceof Object&&4===Object.entries(s).length)void 0!==s.x&&void 0!==s.y&&void 0!==s.z&&void 0!==s.w?i[r]={name:r,value:[s.x,s.y,s.z,s.w],type:SPE_LAYER_UNIFORM_TYPE_VEC4}:void 0!==s.r&&void 0!==s.g&&void 0!==s.b&&void 0!==s.a&&(i[r]={name:r,value:[s.r,s.g,s.b,s.a],type:SPE_LAYER_UNIFORM_TYPE_COLOR});else if(s instanceof Array&&"number"==typeof s[0])Number.isInteger(s[0])?i[r]={name:r,value:[].concat(s),type:SPE_LAYER_UNIFORM_TYPE_ARRAY_INT}:i[r]={name:r,value:[].concat(s),type:SPE_LAYER_UNIFORM_TYPE_ARRAY_FLOAT};else if(s instanceof Array&&s[0]instanceof Object&&2===Object.entries(s[0]).length){if(void 0!==s[0].x&&void 0!==s[0].y){let e=[];for(let t=0;t<s.length;t++)e=e.concat([s[t].x,s[t].y]);i[r]={name:r,value:e,type:SPE_LAYER_UNIFORM_TYPE_ARRAY_VEC2}}}else if(s instanceof Array&&s[0]instanceof Object&&3===Object.entries(s[0]).length){if(void 0!==s[0].x&&void 0!==s[0].y&&void 0!==s[0].z){let e=[];for(let t=0;t<s.length;t++)e=e.concat([s[t].x,s[t].y,s[t].z]);i[r]={name:r,value:e,type:SPE_LAYER_UNIFORM_TYPE_ARRAY_VEC3}}}else if(s instanceof Array&&s[0]instanceof Object&&4===Object.entries(s[0]).length){if(void 0!==s[0].x&&void 0!==s[0].y&&void 0!==s[0].z&&void 0!==s[0].w){let e=[];for(let t=0;t<s.length;t++)e=e.concat([s[t].x,s[t].y,s[t].z,s[t].w]);i[r]={name:r,value:e,type:SPE_LAYER_UNIFORM_TYPE_ARRAY_VEC4}}}else if(s instanceof Array&&s[0]instanceof THREE.Color){if(void 0!==s[0].x&&void 0!==s[0].y&&void 0!==s[0].z&&void 0!==s[0].w){let e=[];for(let t=0;t<s.length;t++)e=e.concat([s[t].r,s[t].g,s[t].b,s[t].a]);i[r]={name:r,value:e,type:SPE_LAYER_UNIFORM_TYPE_ARRAY_COLOR}}}else s instanceof Object&&1===Object.entries(s).length?void 0!==s.elements&&s.elements instanceof Array&&(9===s.elements.length?i[r]={name:r,value:[].concat(s.elements),type:SPE_LAYER_UNIFORM_TYPE_MAT3}:16===s.elements.length?i[r]={name:r,value:[].concat(s.elements),type:SPE_LAYER_UNIFORM_TYPE_MAT4}:console.error("SpeLayer::preprocess_uniforms >>> unsupported matrix-type of uniform: ",s.elements)):"string"==typeof s?i[r]={name:r,value:SPE.CachedTextures[s],type:SPE_LAYER_UNIFORM_TYPE_SAMPLER_2D}:console.error("SpeLayer::preprocess_uniforms >>> unsupported uniform-value: ",s);else{const e=Number(s);Number.isInteger(e)?i[r]={name:r,value:e,type:SPE_LAYER_UNIFORM_TYPE_INT}:i[r]={name:r,value:e,type:SPE_LAYER_UNIFORM_TYPE_FLOAT}}}return i}SPE.CreateLayerFromJSON=function(e,t){const i=e.id,a=e.type,r=preprocess_uniforms(e.id,e.uniforms);return SpeLayer.CreateLayer(i,a,r)}}class SpeLayersList{constructor(e){if(this.mHead=null,this.mShader=null,void 0!==e&&Object.keys(e).length>0)for(let t=0;t<e.length;t++)this.addLayer(t,e[t].type,e[t].uniforms);else this.addLayer(0,SPE_LAYER_TYPE_COLOR,{}),this.addLayer(1,SPE_LAYER_TYPE_LIGHTING,{})}get head(){return this.mHead}set head(e){this.mHead=e}get shader(){return this.mShader}set shader(e){this.mShader=e}addLayer(e,t,i){const a=SpeLayer.CreateLayer(e,t,i);if(null!==a){if(null===this.mHead)this.mHead=a;else{let e=this.mHead;for(;e.next;)e=e.next;e.next=a}return a}console.error("SpeLayersList::addLayer >>> couldnt create a layer of type: ",t)}addLayerBeforeAt(e,t){const i=void 0!==e.id?e.id:100+Math.floor(999*Math.random()),a=void 0!==e.type?e.type:SPE_LAYER_TYPE_COLOR,r="texture"!==a?SpeLayer.DictToUniforms(e):SpeLayerTexture.DictToUniforms(e),s=SpeLayer.CreateLayer(i,a,r);let n=this.head;if(s.next=t,n===t)this.head=s;else{for(;n.next!==t;)n=n.next;n.next=s}return s}removeLayer(e){let t=this.head,i=void 0,a=0;if(t.id==e)this.head=t.next;else for(a=1,i=t,t=t.next;null!=t;){if(t.id==e){i.next=t.next;break}a++,i=t,t=t.next}return a}getLayer(e){let t=this.head;for(;t&&t.id!=e;)t=t.next;return t}updateLayerUniform(e,t){const i=this.getLayer(e);i&&(void 0!==i.uniforms[t]?this.mShader.uniforms[t]={value:i.uniforms[t].value}:console.error(`SpeLayersList::updateLayerUniform >>> uniform ${t} not found in layer`))}updateLayerUniformByLayer(e,t){void 0!==e.uniforms[t]?this.mShader.uniforms[t]={value:e.uniforms[t].value}:console.error(`SpeLayersList::updateLayerUniformByLayer >>> uniform ${t} not found in layer`)}getUniforms(){const e={};let t=this.mHead;for(;t;){for(let[i,a]of Object.entries(t.uniforms))e[i]=a;t=t.next}return e}getDefinesCode(){let e="",t=this.mHead;for(;t;){for(let[i,a]of Object.entries(t.defines))e+=`#define ${i} ${a}\n`;t=t.next}return e}getVertUniformsCode(){let e="",t=this.mHead;for(;t;)e+=t.generateUniformsCodeVert(),t=t.next;return e}getFragUniformsCode(){let e="",t=this.mHead;for(;t;)e+=t.generateUniformsCodeFrag(),t=t.next;return e}getFragShaderCodePreLighting(){let e="",t=this.mHead;for(;t.type!==SPE_LAYER_TYPE_LIGHTING;)e+=t.generateShaderCodeFrag("bef"),t=t.next;return e}getFragShaderCodeLighting(){let e=this.mHead;for(;e.type!==SPE_LAYER_TYPE_LIGHTING;)e=e.next;return e.generateShaderCodeFrag()}getFragShaderCodePostLighting(){let e="",t=this.mHead;for(;t.type!==SPE_LAYER_TYPE_LIGHTING;)t=t.next;for(t=t.next;t;)e+=t.generateShaderCodeFrag("aft"),t=t.next;return e}}class SpeBasicMaterial extends THREE.MeshPhongMaterial{constructor(e,t){super(t),this.mLayersList=null,Object.keys(e).length>0&&(this.mLayersList=new SpeLayersList(e),this.onBeforeCompile=SpeShaderLib.GetSetupCallback(this))}get layersList(){return this.mLayersList}}class SpeLambertMaterial extends THREE.MeshLambertMaterial{constructor(e,t){super(t),this.mLayersList=null,Object.keys(e).length>0&&(this.mLayersList=new SpeLayersList(e),this.onBeforeCompile=SpeShaderLib.GetSetupCallback(this))}get layersList(){return this.mLayersList}}class SpePhongMaterial extends THREE.MeshPhongMaterial{constructor(e,t){super(t),this.mLayersList=null,Object.keys(e).length>0&&(this.mLayersList=new SpeLayersList(e),this.onBeforeCompile=SpeShaderLib.GetSetupCallback(this))}get layersList(){return this.mLayersList}}class SpePhysicalMaterial extends THREE.MeshPhysicalMaterial{constructor(e,t){void 0===t.roughness&&(t.roughness=.3),super(t),this.mLayersList=null,Object.keys(e).length>0&&(this.mLayersList=new SpeLayersList(e),this.onBeforeCompile=SpeShaderLib.GetSetupCallback(this))}get layersList(){return this.mLayersList}}class SpeToonMaterial extends THREE.MeshToonMaterial{constructor(e,t){super(t),this.mLayersList=null,Object.keys(e).length>0&&(this.mLayersList=new SpeLayersList(e),this.onBeforeCompile=SpeShaderLib.GetSetupCallback(this))}get layersList(){return this.mLayersList}}var SpeFontsCache={},SpeCharsCache={};const SPE_PATH_FONTS="assets/fonts/",SPE_DEFAULT_TEXT_FONT="roboto_regular",SPE_DEFAULT_TEXT_CHARACTER=".",SPE_DEFAULT_TEXT_LOD=16;function SpeLoadFont(e){return new Promise(function(t,i){if(SpeFontsCache[e])t(SpeFontsCache[e]);else{const i=new THREE.FontLoader,a=SPE_PATH_FONTS+e+".json";i.load(a,function(i){SpeFontsCache[e]=i,t(i)})}})}function SpeLoadCharData(e,t,i){if(SpeCharsCache[e]){if(SpeCharsCache[e][i]&&SpeCharsCache[e][i].fontFamily===t)return SpeCharsCache[e][i]}else SpeCharsCache[e]={};const a=void 0!==SpeFontsCache[t]?SpeFontsCache[t]:SpeFontsCache[SPE_DEFAULT_TEXT_FONT],r=a.generateShapes(e,1);return SpeCharsCache[e][i]={geometry:new THREE.ShapeBufferGeometry(r,i),fontFamily:t,resolution:a.data.resolution,glyphsHa:a.data.glyphs[e].ha},SpeCharsCache[e][i]}class SpeTextChar3D extends SpeIMesh{constructor(e,t){const i=void 0!==e.char?e.char:SPE_DEFAULT_TEXT_CHARACTER,a=void 0!==e.fontFamily?e.fontFamily:SPE_DEFAULT_TEXT_FONT,r=void 0!==e.lod?e.lod:SPE_DEFAULT_TEXT_LOD,s=SpeLoadCharData(i,a,r);super(s.geometry,t),this.mChar=i,this.mFontFamily=a,this.mLod=r,this.mFontSize=void 0!==e.fontSize?e.fontSize:16,this.mLetterSpacing=void 0!==e.letterSpacing?e.letterSpacing:1,this.mResolution=s.resolution,this.mGlyphsHa=s.glyphsHa,this.mLocalPosition=new THREE.Vector2,this.mCharSize=this.mGlyphsHa*(this.mFontSize/this.mResolution)*this.mLetterSpacing,this.updateFontSize(this.mFontSize)}updateFontSize(e){this.mFontSize=e,this.mCharSize=this.mGlyphsHa*(this.mFontSize/this.mResolution)*this.mLetterSpacing,this.scale.set(this.mFontSize,this.mFontSize,1)}}class SpeTextContainer extends SpeIMesh{constructor(e,t){t.visible=!1,super(e,t)}}class SpeLoaderManager{constructor(e){this.mAssets=e||{},this.mOnFinishCallback=null,this.mNumAssetsToLoad=0,this.mNumAssetsLoaded=0}run(e){this.mOnFinishCallback=e;const t=void 0!==this.mAssets.fonts?this.mAssets.fonts:[],i=void 0!==this.mAssets.images?this.mAssets.images:[],a=void 0!==this.mAssets.models?this.mAssets.models:[],r=void 0!==this.mAssets.animations?this.mAssets.animations:[];if(this.mNumAssetsLoaded=0,this.mNumAssetsToLoad=t.length+i.length+a.length+r.length,this.mNumAssetsToLoad<1)this.mOnFinishCallback();else{const e=this;for(let i=0;i<t.length;i++){const a=new THREE.FontLoader,r=t[i],s=SPE_PATH_FONTS+r+".json";a.load(s,function(t){SpeFontsCache[r]=t,e.mNumAssetsLoaded++,e.mNumAssetsLoaded===e.mNumAssetsToLoad&&e.mOnFinishCallback()})}}}}class SpeRuntime{constructor(e,t,i={}){this.mGltfScene=e,this.mConfig=i,this.mViewportMode=SPE_RUNTIME_VIEWMODE_FULLSCREEN,this.mViewportWidth=window.innerWidth,this.mViewportHeight=window.innerHeight;const a=document.getElementById("canvas3d");this.mRenderer=new THREE.WebGLRenderer({antialias:!0,alpha:!0,canvas:a}),this.mRenderer.setPixelRatio(window.devicePixelRatio),this.mRenderer.setSize(this.mViewportWidth,this.mViewportHeight),this.mRenderer.shadowMap.enabled=!0,this.mRenderer.shadowMap.type=THREE.PCFSoftShadowMap,this.mScene=new SpeScene,this.mSceneOptions={},this.mMainCamera=null,this.mOrbitControls=null,this.mPlayHandler=null,this.mRunning=!1,this.mLoaderManager=new SpeLoaderManager(t),this.mLoaderManager.run(this.onRuntimeAssetsLoaded.bind(this))}run(){requestAnimationFrame(this.run.bind(this)),this.onRender()}onRuntimeAssetsLoaded(){console.info("SpeRuntime >>> Finished loading assets for the spline-runtime"),this.loadFromGltf(this.mGltfScene),window.addEventListener("resize",this.onResize.bind(this)),this.mRunning=!0,this.onResize()}onRender(){this.mRunning&&(SPE_USES_PREVIEW_IMAGE&&(document.querySelector(".spline-preview-image-container").style.display="none",SPE_USES_PREVIEW_IMAGE=!1),this.mPlayHandler&&!this.mPlayHandler.isEnable&&this.mPlayHandler.activate(),this.mOrbitControls&&this.mOrbitControls.update(),this.mScene&&this.mMainCamera&&(this.mRenderer.autoClear=!0,this.mRenderer.render(this.mScene,this.mMainCamera)))}onResize(){this.mRunning&&(this.mViewportMode!==SPE_RUNTIME_VIEWMODE_FULLSCREEN&&this.mViewportMode!==SPE_RUNTIME_VIEWMODE_FULL_WIDTH||(this.mViewportWidth=window.innerWidth),this.mViewportMode!==SPE_RUNTIME_VIEWMODE_FULLSCREEN&&this.mViewportMode!==SPE_RUNTIME_VIEWMODE_FULL_HEIGHT||(this.mViewportHeight=window.innerHeight),this.mMainCamera&&("PerspectiveCamera"===this.mMainCamera.type?this.mMainCamera.aspect=this.mViewportWidth/this.mViewportHeight:"OrthographicCamera"===this.mMainCamera.type&&(this.mMainCamera.left=-this.mViewportWidth/2,this.mMainCamera.right=this.mViewportWidth/2,this.mMainCamera.top=this.mViewportHeight/2,this.mMainCamera.bottom=-this.mViewportHeight/2),this.mMainCamera.updateProjectionMatrix()),this.mRenderer&&this.mRenderer.setSize(this.mViewportWidth,this.mViewportHeight))}loadFromGltf(e){const t=new SpeGltfDecoder(e),[i,a,r]=t.decode();this.mScene=i,this.mMainCamera=a,this.mSceneOptions=r;const s=void 0!==this.mSceneOptions.bgColor?(new THREE.Color).fromArray(this.mSceneOptions.bgColor):new THREE.Color(1644825),n=void 0!==this.mSceneOptions.bgAlpha?this.mSceneOptions.bgAlpha:0;this.mRenderer.setClearColor(s,n),this.mViewportMode=this.mSceneOptions.viewMode,this.mViewportWidth=this.mSceneOptions.viewWidth,this.mViewportHeight=this.mSceneOptions.viewHeight,this.mSceneOptions.useOrbitControls&&(this.mOrbitControls=new THREE.OrbitControls(this.mMainCamera,this.mRenderer.domElement),this.mOrbitControls.target.fromArray(this.mSceneOptions.orbitTarget),this.mOrbitControls.enableRotate=this.mSceneOptions.cameraRotate,this.mOrbitControls.enablePan=this.mSceneOptions.cameraPan,this.mOrbitControls.enableZoom=this.mSceneOptions.cameraZoom,this.mOrbitControls.enableDamping=this.mSceneOptions.orbitDamped,this.mSceneOptions.orbitDamped,this.mOrbitControls.rotateSpeed=1,this.mOrbitControls.panSpeed=1),"function"==typeof Interaction&&(this.mPlayHandler=new PlayMode(this.mRenderer.domElement,this.mScene,this.mMainCamera))}}class SpeScene extends THREE.Scene{constructor(){super()}traverseEntity(e){function t(i){if(i instanceof SpeMesh3D||i instanceof SpeMesh2D||i instanceof SpeTextContainer||i instanceof THREE.Group){e(i);for(let e=0;e<i.children.length;e++)t(i.children[e])}}for(let e=0;e<this.children.length;e++)t(this.children[e])}}class SpeShaderLib{static SetupShader(e,t){e.fragmentShader="\n            /* SPE-Blending helper functions */\n            #define SPE_BLENDING_NORMAL 0\n            #define SPE_BLENDING_MULTIPLY 1\n            #define SPE_BLENDING_SCREEN 2\n            #define SPE_BLENDING_OVERLAY 3\n            vec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {\n                return mix( a, b, alpha );\n            }\n            vec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {\n                return mix( a, a * b, alpha );\n            }\n            vec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {\n                vec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );\n                return mix( a, tmp, alpha );\n            }\n            vec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {\n                vec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );\n                return clamp( mix( a, tmp, alpha ), 0.0, 1.0 );\n            }\n            vec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {\n                /**/ if ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );\n                else if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );\n                else if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );\n                else if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );\n                return vec3( 1.0 );\n            }\n            "+e.fragmentShader,e.vertexShader="\n            #ifdef SPE_USE_LAYER_FRESNEL\n                varying vec3 vWorldViewDir;\n                varying vec3 vWorldNormal;\n            #endif /* SPE_USE_LAYER_FRESNEL */\n            "+e.vertexShader,e.fragmentShader="\n            #ifdef SPE_USE_LAYER_FRESNEL\n                varying vec3 vWorldViewDir;\n                varying vec3 vWorldNormal;\n            #endif /* SPE_USE_LAYER_FRESNEL */\n            "+e.fragmentShader,e.vertexShader=e.vertexShader.replace("#include <project_vertex>","\n            #include <project_vertex>\n            #ifdef SPE_USE_LAYER_FRESNEL\n                vec4 fWorldPosition = modelMatrix * vec4( position, 1.0 );\n                vWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ? \n                                    ( fWorldPosition.xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );\n                vWorldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\n            #endif /* SPE_USE_LAYER_FRESNEL */\n            "),e.vertexShader="\n            #if defined( SPE_USE_LAYER_POINTS ) || defined( SPE_USE_LAYER_LINES )\n                attribute vec3 barycentric;\n                varying vec3 vBarycentric;\n            #endif /* SPE_USE_LAYER_POINTS || SPE_USE_LAYER_LINES */\n        "+e.vertexShader,e.vertexShader=e.vertexShader.replace("#include <begin_vertex>","\n            #include <begin_vertex>\n            #if defined( SPE_USE_LAYER_POINTS ) || defined( SPE_USE_LAYER_LINES )\n                vBarycentric = barycentric;\n            #endif /* SPE_USE_LAYER_POINTS || SPE_USE_LAYER_LINES */\n            "),e.fragmentShader="\n            #if defined( SPE_USE_LAYER_POINTS ) || defined( SPE_USE_LAYER_LINES )\n                varying vec3 vBarycentric;\n                float aastep( float threshold, float dist, float smoothOffset ) {\n                    float afwidth = fwidth( dist ) * 0.5;\n                    return smoothstep( threshold - afwidth - smoothOffset, threshold + afwidth + smoothOffset, dist );\n                }\n            #endif /* SPE_USE_LAYER_POINTS || SPE_USE_LAYER_LINES */\n        "+e.fragmentShader,e.fragmentShader="\n            #ifdef SPE_USE_LAYER_NOISE\n                float random ( in vec2 _st ) {\n                    return sin(sin(dot(_st.xy, vec2(12.834,77.212))) * 320.3456); // Ale: I am usin sin() instead of fract() to create a different noise.\n                }\n                float noise ( in vec2 _st ) {\n                    vec2 i = floor(_st);\n                    vec2 f = fract(_st);\n                    // Four corners in 2D of a tile\n                    float a = random(i);\n                    float b = random(i + vec2(1.0, 0.0)); // Ale: By incrementing disproportionally these values. You get a geometrical distortion.\n                    float c = random(i + vec2(0.0, 1.0));\n                    float d = random(i + vec2(1.0, 1.0));\n                    vec2 u = f * f * (3.0 - 2.0 * f);\n                    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n                }\n                float fbm ( in vec2 _st ) {\n                    float v = 0.0;\n                    float a = 0.5;\n                    vec2 shift = vec2(100.0);\n                    // Rotate to reduce axial bias\n                    mat2 rot = mat2(cos(0.5), sin(0.5),\n                                    -sin(0.5), cos(0.50));\n                    for (int i = 0; i < SPE_NOISE_NUM_OCTAVES; ++i) {\n                        v += a * noise(_st);\n                        _st = rot * _st * 2.0 + shift;\n                        a *= 0.5;\n                    }\n                    return v;\n                }\n            #endif /* SPE_USE_LAYER_NOISE */\n            "+e.fragmentShader,e.fragmentShader=e.fragmentShader.replace("#include <normal_fragment_begin>",""),e.fragmentShader=e.fragmentShader.replace("#include <normal_fragment_maps>",""),t instanceof SpeBasicMaterial&&(e.fragmentShader=e.fragmentShader.replace("#include <lights_phong_fragment>\n                #include <lights_fragment_begin>\n                #include <lights_fragment_maps>\n                #include <lights_fragment_end>",""),e.fragmentShader=e.fragmentShader.replace("vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;","vec3 outgoingLight = diffuseColor.rgb;")),t instanceof SpeLambertMaterial&&(e.vertexShader="\n                #ifdef SPE_USE_LAYER_NORMAL\n                    varying vec3 vNormal;\n                #endif /* SPE_USE_LAYER_NORMAL */\n                "+e.vertexShader,e.vertexShader=e.vertexShader.replace("#include <defaultnormal_vertex>","\n                #include <defaultnormal_vertex>\n                #ifdef SPE_USE_LAYER_NORMAL\n                    vNormal = normalize( transformedNormal );\n                #endif /* SPE_USE_LAYER_NORMAL */\n                "),e.fragmentShader="\n                #ifdef SPE_USE_LAYER_NORMAL\n                    varying vec3 vNormal;\n                #endif /* SPE_USE_LAYER_NORMAL */\n                "+e.fragmentShader,e.fragmentShader=e.fragmentShader.replace("vec4 diffuseColor = vec4( diffuse, opacity );","\n                #ifdef SPE_USE_LAYER_NORMAL\n                    #include <normal_fragment_begin>\n                    #include <normal_fragment_maps>\n                #endif /* SPE_USE_LAYER_NORMAL */\n                    float accumAlpha = 0.0;\n                    vec3 bef = vec3( 1.0 );\n                    #before\n                    vec4 diffuseColor = vec4( bef, 1.0 );\n                ")),e.vertexShader=e.vertexShader.replace("#include <common>","\n            #include <common>\n            #ifdef SPE_USE_LAYER_DEPTH\n                varying vec4 dWorldPosition;\n            #endif /* SPE_USE_LAYER_DEPTH */\n            "),e.vertexShader=e.vertexShader.replace("#include <worldpos_vertex>","\n            #include <worldpos_vertex>\n            #ifdef SPE_USE_LAYER_DEPTH\n                dWorldPosition = modelMatrix * vec4( transformed, 1.0 );\n            #endif\n            "),e.fragmentShader="\n            #ifdef SPE_USE_LAYER_DEPTH\n                varying vec4 dWorldPosition;\n            #endif /* SPE_USE_LAYER_DEPTH */\n            "+e.fragmentShader,e.fragmentShader=e.fragmentShader.replace("vec4 diffuseColor = vec4( diffuse, opacity );","\n                #include <normal_fragment_begin>\n                #include <normal_fragment_maps>\n                float accumAlpha = 0.0;\n                vec3 bef = vec3( 1.0 );\n                #before\n                vec4 diffuseColor = vec4( bef, 1.0 );\n            "),e.fragmentShader=e.fragmentShader.replace("gl_FragColor = vec4( outgoingLight, diffuseColor.a );","\n                #lighting\n                vec3 aft = outgoingLight;\n                #after\n                gl_FragColor = vec4( aft, accumAlpha * opacity );\n            ")}static GetSetupCallback(material){let string="";for(let e=0;e<material.uuid.length;++e){const t=material.uuid[e];"-"!=t&&(string+=t)}return eval(`shader => {\n            // Hashing required as in issue https://github.com/mrdoob/three.js/issues/13192\n            const __hash___${string} = true;\n            const layersList = material.layersList;\n            // Inject base functionality into both vertex and fragment shaders\n            SpeShaderLib.SetupShader( shader, material );\n            shader.uniforms = THREE.UniformsUtils.merge( [ shader.uniforms, layersList.getUniforms() ] );\n            for ( let [key, uniform] of Object.entries( shader.uniforms ) ) {\n                if ( uniform.value && uniform.value.isTexture ) {\n                    uniform.value.needsUpdate = true;\n                }\n            }\n            // Inject shader-code in fragment shader previous to the lighting step\n            shader.fragmentShader = shader.fragmentShader.replace( '#before', layersList.getFragShaderCodePreLighting() );\n            // Inject shader-code in fragment shader for the lighting step\n            shader.fragmentShader = shader.fragmentShader.replace( '#lighting', layersList.getFragShaderCodeLighting() );\n            // Inject shader-code in fragment shader after the lighting step\n            shader.fragmentShader = shader.fragmentShader.replace( '#after', layersList.getFragShaderCodePostLighting() );\n            // Inject uniforms variables in both vertex and fragment shaders\n            shader.vertexShader = layersList.getVertUniformsCode() + shader.vertexShader;\n            shader.fragmentShader = layersList.getFragUniformsCode() + shader.fragmentShader;\n            // Inject defines in both vertex and fragment shaders\n            shader.vertexShader = layersList.getDefinesCode() + shader.vertexShader;\n            shader.fragmentShader = layersList.getDefinesCode() + shader.fragmentShader;\n            // Link the shader to its related layers-list\n            layersList.shader = shader;\n        }`)}}class SpeStack{constructor(){this.elements=[]}push(e){this.elements.push(e)}pop(){return 0===this.elements.length?null:this.elements.pop()}top(){return this.elements[this.elements.length-1]}empty(){return 0===this.elements.length}}class SpeQueue{constructor(){this.elements=[]}push(e){this.elements.push(e)}pop(){return 0===this.elements.length?null:this.elements.shift()}front(){return this.elements[0]}empty(){return 0===this.elements.length}}function Interaction(e){this.uuid=THREE.MathUtils.generateUUID(),this.object=e,this.states=[],this.events=[],this.selectedState,this.animation,this.currentState,this.prevState,this.statesManager=new InteractionStatesManager(this)}function IsValidURL(e){return-1===e.indexOf("https")?(console.warn("Tried opening an url without https protocol"),!1):!!new RegExp("^(https?:\\/\\/)?((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|((\\d{1,3}\\.){3}\\d{1,3}))(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*(\\?[;&a-z\\d%_.~+=-]*)?(\\#[-a-z\\d_]*)?$","i").test(e)}function InteractionEvent(e,t){this.targets=[],this._type=e,this.key=t,this.ui={isCollapsed:!1}}function InteractionState(){this.uuid=THREE.MathUtils.generateUUID(),this.name,this.position=new THREE.Vector3,this.rotation=new THREE.Euler,this.scale=new THREE.Vector3,this.hiddenMatrix=new THREE.Matrix4}function InteractionTarget(){this._object,this.state,this.easing=InteractionTarget.EASING.EASE_IN_OUT,this.duration=1e3,this.delay=0,this.cubicControls=[.5,.05,.1,.3],this.springParameters={mass:1,stiffness:80,damping:10,velocity:0},this.repeat=!1,this.cycle=!1,this.rewind=!1,this.url=""}function InteractionStatesManager(e){this.i=e}function PlayMode(e,t,i){const a=new SPE.Raycaster;this.isEnable;let r,s={};function n(e){a.setFromCamera(c(e),i);const t=s[InteractionEvent.TYPE.MOUSE_DOWN];for(let e=0,i=t.length;e<i;++e)if(a.intersectObject(t[e].object,!1).length>0){t[e].interactionEvent.dispatch();break}}function o(e){a.setFromCamera(c(e),i);const t=s[InteractionEvent.TYPE.MOUSE_UP];for(let e=0,i=t.length;e<i;++e)if(a.intersectObject(t[e].object,!1).length>0){t[e].interactionEvent.dispatch();break}}function h(e){a.setFromCamera(c(e),i);const t=s[InteractionEvent.TYPE.MOUSE_HOVER].find(e=>a.intersectObject(e.object,!1).length>0),n=void 0!==t?t.interactionEvent:void 0;r!==n&&(void 0!==r&&r.dispatchReverse(),void 0!==t&&n.dispatch()),r=n}function l(e){const t=-1*(e.pageX-window.innerWidth/2),i=1*(e.pageY-window.innerHeight/2);s[InteractionEvent.TYPE.LOOK_AT].forEach(e=>{e.object.interaction.lookAt(t,i)})}function m(e){s[InteractionEvent.TYPE.KEY_DOWN].forEach(t=>{t.interactionEvent.key===e.key&&t.interactionEvent.dispatch()})}function d(e){s[InteractionEvent.TYPE.KEY_UP].forEach(t=>{t.interactionEvent.key===e.key&&t.interactionEvent.dispatch()})}function c(t){var i=e.getBoundingClientRect();return{x:(t.clientX-i.left)/i.width*2-1,y:-(t.clientY-i.top)/i.height*2+1}}this.activate=function(){this.isEnable=!0;for(const e in InteractionEvent.TYPE)s[InteractionEvent.TYPE[e]]=[];t.traverseEntity(function(e){if(void 0!==e.interaction){e.interaction.start();const t=e.interaction.events;for(let i=0,a=t.length;i<a;++i)s[t[i].type].push({interactionEvent:t[i],object:e})}}),s[InteractionEvent.TYPE.MOUSE_DOWN].length>0&&e.addEventListener("pointerdown",n,!1),s[InteractionEvent.TYPE.MOUSE_UP].length>0&&e.addEventListener("pointerup",o,!1),s[InteractionEvent.TYPE.MOUSE_HOVER].length>0&&e.addEventListener("pointermove",h,!1),s[InteractionEvent.TYPE.LOOK_AT].length>0&&e.addEventListener("mousemove",l,!1),s[InteractionEvent.TYPE.KEY_DOWN].length>0&&document.addEventListener("keydown",m,!1),s[InteractionEvent.TYPE.KEY_UP].length>0&&document.addEventListener("keyup",d,!1)},this.deactivate=function(){t.traverseEntity(function(e){void 0!==e.interaction&&e.interaction.end()}),s[InteractionEvent.TYPE.MOUSE_DOWN].length>0&&e.removeEventListener("pointerdown",n),s[InteractionEvent.TYPE.MOUSE_UP].length>0&&e.removeEventListener("pointerup",o),s[InteractionEvent.TYPE.MOUSE_HOVER].length>0&&e.removeEventListener("pointermove",h),s[InteractionEvent.TYPE.LOOK_AT].length>0&&e.removeEventListener("pointermove",l,!1),s[InteractionEvent.TYPE.KEY_DOWN].length>0&&document.removeEventListener("keydown",m),s[InteractionEvent.TYPE.KEY_UP].length>0&&document.removeEventListener("keyup",d),s={},this.isEnable=!1},this.reset=function(){t.traverseEntity(function(e){e.interaction.start()})}}THREE.OrbitControls=function(e,t){var i,a,r,s,n,o;void 0===t&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),t===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=e,this.domElement=t,this.enabled=!0,this.target=new THREE.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.enableKeys=!0,this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},this.mouseButtons={LEFT:THREE.MOUSE.ROTATE,MIDDLE:THREE.MOUSE.DOLLY,RIGHT:THREE.MOUSE.PAN},this.touches={ONE:THREE.TOUCH.ROTATE,TWO:THREE.TOUCH.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=function(){return p.phi},this.getAzimuthalAngle=function(){return p.theta},this.saveState=function(){h.target0.copy(h.target),h.position0.copy(h.object.position),h.zoom0=h.object.zoom},this.reset=function(){h.target.copy(h.target0),h.object.position.copy(h.position0),h.object.zoom=h.zoom0,h.object.updateProjectionMatrix(),h.dispatchEvent(l),h.update(),u=c.NONE},this.update=(i=new THREE.Vector3,a=(new THREE.Quaternion).setFromUnitVectors(e.up,new THREE.Vector3(0,1,0)),r=a.clone().inverse(),s=new THREE.Vector3,n=new THREE.Quaternion,o=2*Math.PI,function(){var e=h.object.position;i.copy(e).sub(h.target),i.applyQuaternion(a),p.setFromVector3(i),h.autoRotate&&u===c.NONE&&P(2*Math.PI/60/60*h.autoRotateSpeed),h.enableDamping?(p.theta+=E.theta*h.dampingFactor,p.phi+=E.phi*h.dampingFactor):(p.theta+=E.theta,p.phi+=E.phi);var t=h.minAzimuthAngle,m=h.maxAzimuthAngle;return isFinite(t)&&isFinite(m)&&(t<-Math.PI?t+=o:t>Math.PI&&(t-=o),m<-Math.PI?m+=o:m>Math.PI&&(m-=o),p.theta=t<m?Math.max(t,Math.min(m,p.theta)):p.theta>(t+m)/2?Math.max(t,p.theta):Math.min(m,p.theta)),p.phi=Math.max(h.minPolarAngle,Math.min(h.maxPolarAngle,p.phi)),p.makeSafe(),p.radius*=_,p.radius=Math.max(h.minDistance,Math.min(h.maxDistance,p.radius)),!0===h.enableDamping?h.target.addScaledVector(g,h.dampingFactor):h.target.add(g),i.setFromSpherical(p),i.applyQuaternion(r),e.copy(h.target).add(i),h.object.lookAt(h.target),!0===h.enableDamping?(E.theta*=1-h.dampingFactor,E.phi*=1-h.dampingFactor,g.multiplyScalar(1-h.dampingFactor)):(E.set(0,0,0),g.set(0,0,0)),_=1,!!(y||s.distanceToSquared(h.object.position)>f||8*(1-n.dot(h.object.quaternion))>f)&&(h.dispatchEvent(l),s.copy(h.object.position),n.copy(h.object.quaternion),y=!1,!0)}),this.dispose=function(){h.domElement.removeEventListener("contextmenu",ee,!1),h.domElement.removeEventListener("pointerdown",k,!1),h.domElement.removeEventListener("wheel",q,!1),h.domElement.removeEventListener("touchstart",Z,!1),h.domElement.removeEventListener("touchend",J,!1),h.domElement.removeEventListener("touchmove",Q,!1),h.domElement.ownerDocument.removeEventListener("pointermove",W,!1),h.domElement.ownerDocument.removeEventListener("pointerup",X,!1),h.domElement.removeEventListener("keydown",K,!1)};var h=this,l={type:"change"},m={type:"start"},d={type:"end"},c={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6},u=c.NONE,f=1e-6,p=new THREE.Spherical,E=new THREE.Spherical,_=1,g=new THREE.Vector3,y=!1,v=new THREE.Vector2,S=new THREE.Vector2,T=new THREE.Vector2,R=new THREE.Vector2,I=new THREE.Vector2,w=new THREE.Vector2,b=new THREE.Vector2,L=new THREE.Vector2,x=new THREE.Vector2;function M(){return Math.pow(.95,h.zoomSpeed)}function P(e){E.theta-=e}function A(e){E.phi-=e}var $,O=($=new THREE.Vector3,function(e,t){$.setFromMatrixColumn(t,0),$.multiplyScalar(-e),g.add($)}),U=function(){var e=new THREE.Vector3;return function(t,i){!0===h.screenSpacePanning?e.setFromMatrixColumn(i,1):(e.setFromMatrixColumn(i,0),e.crossVectors(h.object.up,e)),e.multiplyScalar(t),g.add(e)}}(),D=function(){var e=new THREE.Vector3;return function(t,i){var a=h.domElement;if(h.object.isPerspectiveCamera){var r=h.object.position;e.copy(r).sub(h.target);var s=e.length();s*=Math.tan(h.object.fov/2*Math.PI/180),O(2*t*s/a.clientHeight,h.object.matrix),U(2*i*s/a.clientHeight,h.object.matrix)}else h.object.isOrthographicCamera?(O(t*(h.object.right-h.object.left)/h.object.zoom/a.clientWidth,h.object.matrix),U(i*(h.object.top-h.object.bottom)/h.object.zoom/a.clientHeight,h.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),h.enablePan=!1)}}();function C(e){h.object.isPerspectiveCamera?_/=e:h.object.isOrthographicCamera?(h.object.zoom=Math.max(h.minZoom,Math.min(h.maxZoom,h.object.zoom*e)),h.object.updateProjectionMatrix(),y=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),h.enableZoom=!1)}function H(e){h.object.isPerspectiveCamera?_*=e:h.object.isOrthographicCamera?(h.object.zoom=Math.max(h.minZoom,Math.min(h.maxZoom,h.object.zoom/e)),h.object.updateProjectionMatrix(),y=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),h.enableZoom=!1)}function G(e){v.set(e.clientX,e.clientY)}function N(e){R.set(e.clientX,e.clientY)}function B(e){if(1==e.touches.length)v.set(e.touches[0].pageX,e.touches[0].pageY);else{var t=.5*(e.touches[0].pageX+e.touches[1].pageX),i=.5*(e.touches[0].pageY+e.touches[1].pageY);v.set(t,i)}}function z(e){if(1==e.touches.length)R.set(e.touches[0].pageX,e.touches[0].pageY);else{var t=.5*(e.touches[0].pageX+e.touches[1].pageX),i=.5*(e.touches[0].pageY+e.touches[1].pageY);R.set(t,i)}}function Y(e){var t=e.touches[0].pageX-e.touches[1].pageX,i=e.touches[0].pageY-e.touches[1].pageY,a=Math.sqrt(t*t+i*i);b.set(0,a)}function V(e){if(1==e.touches.length)S.set(e.touches[0].pageX,e.touches[0].pageY);else{var t=.5*(e.touches[0].pageX+e.touches[1].pageX),i=.5*(e.touches[0].pageY+e.touches[1].pageY);S.set(t,i)}T.subVectors(S,v).multiplyScalar(h.rotateSpeed);var a=h.domElement;P(2*Math.PI*T.x/a.clientHeight),A(2*Math.PI*T.y/a.clientHeight),v.copy(S)}function F(e){if(1==e.touches.length)I.set(e.touches[0].pageX,e.touches[0].pageY);else{var t=.5*(e.touches[0].pageX+e.touches[1].pageX),i=.5*(e.touches[0].pageY+e.touches[1].pageY);I.set(t,i)}w.subVectors(I,R).multiplyScalar(h.panSpeed),D(w.x,w.y),R.copy(I)}function j(e){var t=e.touches[0].pageX-e.touches[1].pageX,i=e.touches[0].pageY-e.touches[1].pageY,a=Math.sqrt(t*t+i*i);L.set(0,a),x.set(0,Math.pow(L.y/b.y,h.zoomSpeed)),C(x.y),b.copy(L)}function k(e){if(!1!==h.enabled)switch(e.pointerType){case"mouse":case"pen":!function(e){var t;switch(e.preventDefault(),h.domElement.focus?h.domElement.focus():window.focus(),e.button){case 0:t=h.mouseButtons.LEFT;break;case 1:t=h.mouseButtons.MIDDLE;break;case 2:t=h.mouseButtons.RIGHT;break;default:t=-1}switch(t){case THREE.MOUSE.DOLLY:if(!1===h.enableZoom)return;!function(e){b.set(e.clientX,e.clientY)}(e),u=c.DOLLY;break;case THREE.MOUSE.ROTATE:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===h.enablePan)return;N(e),u=c.PAN}else{if(!1===h.enableRotate)return;G(e),u=c.ROTATE}break;case THREE.MOUSE.PAN:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===h.enableRotate)return;G(e),u=c.ROTATE}else{if(!1===h.enablePan)return;N(e),u=c.PAN}break;default:u=c.NONE}u!==c.NONE&&(h.domElement.ownerDocument.addEventListener("pointermove",W,!1),h.domElement.ownerDocument.addEventListener("pointerup",X,!1),h.dispatchEvent(m))}(e)}}function W(e){if(!1!==h.enabled)switch(e.pointerType){case"mouse":case"pen":!function(e){if(!1===h.enabled)return;switch(e.preventDefault(),u){case c.ROTATE:if(!1===h.enableRotate)return;!function(e){S.set(e.clientX,e.clientY),T.subVectors(S,v).multiplyScalar(h.rotateSpeed);var t=h.domElement;P(2*Math.PI*T.x/t.clientHeight),A(2*Math.PI*T.y/t.clientHeight),v.copy(S),h.update()}(e);break;case c.DOLLY:if(!1===h.enableZoom)return;!function(e){L.set(e.clientX,e.clientY),x.subVectors(L,b),x.y>0?C(M()):x.y<0&&H(M()),b.copy(L),h.update()}(e);break;case c.PAN:if(!1===h.enablePan)return;!function(e){I.set(e.clientX,e.clientY),w.subVectors(I,R).multiplyScalar(h.panSpeed),D(w.x,w.y),R.copy(I),h.update()}(e)}}(e)}}function X(e){if(!1!==h.enabled)switch(e.pointerType){case"mouse":case"pen":!function(e){if(!1===h.enabled)return;h.domElement.ownerDocument.removeEventListener("pointermove",W,!1),h.domElement.ownerDocument.removeEventListener("pointerup",X,!1),h.dispatchEvent(d),u=c.NONE}()}}function q(e){!1===h.enabled||!1===h.enableZoom||u!==c.NONE&&u!==c.ROTATE||(e.preventDefault(),e.stopPropagation(),h.dispatchEvent(m),function(e){e.deltaY<0?H(M()):e.deltaY>0&&C(M()),h.update()}(e),h.dispatchEvent(d))}function K(e){!1!==h.enabled&&!1!==h.enableKeys&&!1!==h.enablePan&&function(e){var t=!1;switch(e.keyCode){case h.keys.UP:D(0,h.keyPanSpeed),t=!0;break;case h.keys.BOTTOM:D(0,-h.keyPanSpeed),t=!0;break;case h.keys.LEFT:D(h.keyPanSpeed,0),t=!0;break;case h.keys.RIGHT:D(-h.keyPanSpeed,0),t=!0}t&&(e.preventDefault(),h.update())}(e)}function Z(e){if(!1!==h.enabled){switch(e.preventDefault(),e.touches.length){case 1:switch(h.touches.ONE){case THREE.TOUCH.ROTATE:if(!1===h.enableRotate)return;B(e),u=c.TOUCH_ROTATE;break;case THREE.TOUCH.PAN:if(!1===h.enablePan)return;z(e),u=c.TOUCH_PAN;break;default:u=c.NONE}break;case 2:switch(h.touches.TWO){case THREE.TOUCH.DOLLY_PAN:if(!1===h.enableZoom&&!1===h.enablePan)return;!function(e){h.enableZoom&&Y(e),h.enablePan&&z(e)}(e),u=c.TOUCH_DOLLY_PAN;break;case THREE.TOUCH.DOLLY_ROTATE:if(!1===h.enableZoom&&!1===h.enableRotate)return;!function(e){h.enableZoom&&Y(e),h.enableRotate&&B(e)}(e),u=c.TOUCH_DOLLY_ROTATE;break;default:u=c.NONE}break;default:u=c.NONE}u!==c.NONE&&h.dispatchEvent(m)}}function Q(e){if(!1!==h.enabled)switch(e.preventDefault(),e.stopPropagation(),u){case c.TOUCH_ROTATE:if(!1===h.enableRotate)return;V(e),h.update();break;case c.TOUCH_PAN:if(!1===h.enablePan)return;F(e),h.update();break;case c.TOUCH_DOLLY_PAN:if(!1===h.enableZoom&&!1===h.enablePan)return;!function(e){h.enableZoom&&j(e),h.enablePan&&F(e)}(e),h.update();break;case c.TOUCH_DOLLY_ROTATE:if(!1===h.enableZoom&&!1===h.enableRotate)return;!function(e){h.enableZoom&&j(e),h.enableRotate&&V(e)}(e),h.update();break;default:u=c.NONE}}function J(e){!1!==h.enabled&&(h.dispatchEvent(d),u=c.NONE)}function ee(e){!1!==h.enabled&&e.preventDefault()}h.domElement.addEventListener("contextmenu",ee,!1),h.domElement.addEventListener("pointerdown",k,!1),h.domElement.addEventListener("wheel",q,!1),h.domElement.addEventListener("touchstart",Z,!1),h.domElement.addEventListener("touchend",J,!1),h.domElement.addEventListener("touchmove",Q,!1),h.domElement.addEventListener("keydown",K,!1),-1===h.domElement.tabIndex&&(h.domElement.tabIndex=0),this.update()},THREE.OrbitControls.prototype=Object.create(THREE.EventDispatcher.prototype),THREE.OrbitControls.prototype.constructor=THREE.OrbitControls,THREE.MapControls=function(e,t){THREE.OrbitControls.call(this,e,t),this.screenSpacePanning=!1,this.mouseButtons.LEFT=THREE.MOUSE.PAN,this.mouseButtons.RIGHT=THREE.MOUSE.ROTATE,this.touches.ONE=THREE.TOUCH.PAN,this.touches.TWO=THREE.TOUCH.DOLLY_ROTATE},THREE.MapControls.prototype=Object.create(THREE.EventDispatcher.prototype),THREE.MapControls.prototype.constructor=THREE.MapControls,Interaction.targets=new Set,Interaction.prototype={constructor:Interaction,newState:function(e){const t=new InteractionState;return t.name=e,t.update(this.object),this.selectedState=this.states.length,this.states.push(t),t},addState:function(e,t){this.states.splice(t,0,e)},removeState:function(e){this.selectedState===e&&(this.selectedState=void 0),this.states.splice(e,1)},selectState:function(e){void 0!==e&&this.states[e].execute(this.object),this.selectedState=e},getEventType:function(e){return this.events.find(t=>t.type===e)},hasEventType:function(e,t){return e===InteractionEvent.TYPE.KEY_DOWN||e===InteractionEvent.TYPE.KEY_UP?void 0!==t&&this.events.some(i=>i.type===e&&i.key===t):this.events.some(t=>t.type===e)},newEvent:function(){const e=InteractionEvent.ORDER.find(e=>!1===this.hasEventType(e)),t=new InteractionEvent(e);return this.events.push(t),t},addEvent:function(e,t){this.events.splice(t,0,e);const i=this.events[t].targets;for(let e=0,t=i.length;e<t;++e)void 0!==i[e].object&&Interaction.targets.add(i[e])},removeEvent:function(e){const t=this.events[e].targets;for(let e=0,i=t.length;e<i;++e)void 0!==t[e].object&&Interaction.targets.delete(t[e]);this.events.splice(e,1)},copy:function(e){this.selectedState=e.selectedState;for(let t=0,i=e.states.length;t<i;++t)this.addState(e.states[t].clone(),t);for(let t=0,i=e.events.length;t<i;++t){this.addEvent(e.events[t].clone(),t);const i=e.events[t].targets;for(let a=0,r=i.length;a<r;++a){const r=i[a].clone();i[a].object===e.object?(r.object=this.object,r.state=this.states[e.states.indexOf(i[a].state)]):(r.object=i[a].object,r.state=i[a].state),this.events[t].addTarget(r,a)}}return this},clone:function(e){return new Interaction(e).copy(this)},toJSON:function(e){const t={};if(t.uuid=this.uuid,void 0!==this.selectedState&&(t.selectedState=this.selectedState),this.states.length>0){t.states=[];for(let r=0,s=this.states.length;r<s;++r)t.states.push((i=e.interactionStates,a=this.states[r],void 0===i[a.uuid]&&(i[a.uuid]=a.toJSON(e)),a.uuid))}var i,a;if(this.events.length>0){t.events=[];for(let i=0,a=this.events.length;i<a;++i)t.events.push(this.events[i].toJSON(e))}return t},fromJSON:function(e,t,i){if(this.uuid=e.uuid,this.selectedState=e.selectedState,this.states=[],this.events=[],void 0!==e.states)for(let t=0,a=e.states.length;t<a;++t)this.states.push(i[e.states[t]]);if(void 0!==e.events)for(let a=0,r=e.events.length;a<r;++a)this.events.push((new InteractionEvent).fromJSON(e.events[a],t,i));return this},start:function(){if(void 0!==this.animation&&(this.animation.pause(),this.animation=void 0,this._removeBackLayer()),this.states.length>1){this.states[0].execute(this.object),this.currentState=this.states[0],this.prevState=void 0;const e=this.getEventType(InteractionEvent.TYPE.START);void 0!==e&&e.targets.length>0&&this.play(e.targets[0])}},end:function(){void 0!==this.animation&&(this.animation.pause(),this.animation=void 0,this._removeBackLayer()),this.states.length>1&&this.states[this.selectedState].execute(this.object),this.currentState=void 0,this.prevState=void 0},lookAt:function(e,t){const i=new THREE.Vector3(e,t,-600);this.object.lookAt(i)},play:function(e){this.animate(e.state,e)},reverse:function(e){this.animate(this.prevState,e)},_removeBackLayer:function(){if(void 0!==this.object.material){const e=this.object.material;if(Array.isArray(e))for(let t=0,i=e.length;t<i;++t){const i=e[t].layersList;let a=i.head;for(;a;)if(a.backLayer){delete a.backLayer;const e=a.next;i.removeLayer(a.id),a=e}else a.isBack?(delete a.isBack,a=a.next):a=a.next}else{const t=e.layersList;let i=t.head;for(;i;)for(;i;)if(i.backLayer){delete i.backLayer;const e=i.next;t.removeLayer(i.id),i=e}else i.isBack?(delete i.isBack,i=i.next):i=i.next}}},getTimingFunction:function(e,t,i){switch(e){case InteractionTarget.EASING.LINEAR:return"cubicBezier( 0, 0, 1, 1 )";case InteractionTarget.EASING.EASE:return"cubicBezier( .25, .1, .25, 1 )";case InteractionTarget.EASING.EASE_IN:return"cubicBezier( .42, 0, 1, 1 )";case InteractionTarget.EASING.EASE_OUT:return"cubicBezier( 0, 0, .58, 1 )";case InteractionTarget.EASING.EASE_IN_OUT:return"cubicBezier( .42, 0, .58, 1 )";case InteractionTarget.EASING.CUBIC:return`cubicBezier( ${t[0]}, ${t[1]}, ${t[2]}, ${t[3]} )`;case InteractionTarget.EASING.SPRING:return`spring( ${i.mass}, ${i.stiffness}, ${i.damping}, ${i.velocity} )`}},animate:function(e,t){this.currentState!==e&&(this.prevState=this.currentState,this.currentState=e),void 0!==this.animation&&this.animation.pause(),this._removeBackLayer(),!0===t.cycle&&!0===t.repeat?this.animation=anime.timeline({duration:t.duration,delay:t.delay/2,endDelay:t.delay/2,direction:"alternate",loop:!0,rewind:t.rewind,easing:this.getTimingFunction(t.easing,t.cubicControls,t.springParameters)}):!0===t.cycle&&!1===t.repeat?this.animation=anime.timeline({duration:t.duration,delay:t.delay,endDelay:t.delay/2,direction:"alternate",rewind:t.rewind,easing:this.getTimingFunction(t.easing,t.cubicControls,t.springParameters)}):!1===t.cycle&&!0===t.repeat?this.animation=anime.timeline({duration:t.duration,delay:t.delay,direction:"normal",loop:!0,easing:this.getTimingFunction(t.easing,t.cubicControls,t.springParameters)}):this.animation=anime.timeline({duration:t.duration,delay:t.delay,direction:"normal",easing:this.getTimingFunction(t.easing,t.cubicControls,t.springParameters)}),this.animation.finished.then(()=>{this._removeBackLayer()}),this.animateMatrix(e),this.animateGeometry(e),this.animateMaterial(e),this.animateCamera(e)},animateMatrix:function(e){if(!1===this.object.position.equals(e.position)){const t=this.object.position.clone(),i={t:0};this.animation.add({targets:i,t:1,update:()=>{this.object.position.lerpVectors(t,e.position,i.t)}},0)}if(!1===this.object.scale.equals(e.scale)){const t=this.object.scale.clone(),i={t:0};this.animation.add({targets:i,t:1,update:()=>{this.object.scale.lerpVectors(t,e.scale,i.t)}},0)}if(!1===this.object.rotation.equals(e.rotation)){const t=this.object.quaternion.clone(),i={t:0},a={x:this.object.rotation.x-e.rotation.x,y:this.object.rotation.y-e.rotation.y,z:this.object.rotation.z-e.rotation.z},r=e.rotation.clone(),s=.01*THREE.Math.DEG2RAD,n=359.99*THREE.Math.DEG2RAD;a.x===2*Math.PI?0===r.x?r.x=s:r.x===2*Math.PI&&(r.x=n):a.x===2*-Math.PI&&(0===r.x?r.x=-s:r.x===2*Math.PI&&(r.x=-n)),a.y===2*Math.PI?0===r.y?r.y=s:r.y===2*Math.PI&&(r.y=n):a.y===2*-Math.PI&&(0===r.y?r.y=-s:r.y===2*Math.PI&&(r.y=-n)),a.z===2*Math.PI?0===r.z?r.z=s:r.z===2*Math.PI&&(r.z=n):a.z===2*-Math.PI&&(0===r.z?r.z=-s:r.z===2*Math.PI&&(r.z=-n));const o=(new THREE.Quaternion).setFromEuler(r);this.animation.add({targets:i,t:1,update:()=>{SPE.Math.slerp(t,o,this.object.quaternion,i.t)}},0)}const t=new THREE.Vector3,i=new THREE.Quaternion,a=new THREE.Vector3,r=new THREE.Vector3,s=new THREE.Quaternion,n=new THREE.Vector3,o=new THREE.Vector3,h=new THREE.Quaternion,l=new THREE.Vector3;if(this.object.hiddenMatrix.decompose(t,i,a),e.hiddenMatrix.decompose(r,s,n),!1===this.object.hiddenMatrix.equals(e.hiddenMatrix)){const e={t:0};this.animation.add({targets:e,t:1,update:()=>{THREE.Quaternion.slerp(i,s,h,e.t),o.lerpVectors(t,r,e.t),l.lerpVectors(a,n,e.t),this.object.hiddenMatrix.compose(o,h,l)}},0)}},animateGeometry:function(e){if(void 0===this.object.geometry)return;const t=this.object.geometry.userData.parameters;e.geometry.width===t.width&&e.geometry.height===t.height&&e.geometry.depth===t.depth||this.animation.add({targets:this.object.geometry.userData.parameters,width:e.geometry.width,height:e.geometry.height,depth:e.geometry.depth,update:()=>{const e=SPE[this.object.geometry.userData.type].buildFromGeometry(this.object.geometry,{width:t.width,height:t.height,depth:t.depth});this.object.updateGeometry(e)}},0)},animateMaterial:function(e){if(void 0===this.object.material)return;const t=(e,t,i,a)=>{const r=e.layersList;for(let e=0,s=(a=void 0!==a?a:t.paramNames).length;e<s;++e){const s=a[e],n=`f${t.id}_${s}`,o=`f${i.id}_${s}`,h=t.uniforms[n],l=i.uniforms[o];"mode"!==s&&"boolean"!=typeof h.value?"number"!=typeof h.value?h.value instanceof THREE.Vector2?!1===h.value.equals(l.value)&&this.animation.add({targets:h.value,x:l.value.x,y:l.value.y,update:function(){r.updateLayerUniformByLayer(t,n)}},0):h.value instanceof THREE.Vector3?!1===h.value.equals(l.value)&&this.animation.add({targets:h.value,x:l.value.x,y:l.value.y,z:l.value.z,update:function(){r.updateLayerUniformByLayer(t,n)}},0):h.value instanceof THREE.Color&&!1===h.value.equals(l.value)&&this.animation.add({targets:h.value,r:l.value.r,g:l.value.g,b:l.value.b,update:function(){r.updateLayerUniformByLayer(t,n)}},0):h.value!==l.value&&this.animation.add({targets:h,value:l.value,update:function(){r.updateLayerUniformByLayer(t,n)}},0):h.value!==l.value&&(h.value=l.value,r.updateLayerUniformByLayer(t,n))}if(t.backLayer){const e=t.backLayer.id,i=`f${e}_alpha`,a=t.backLayer.uniforms[i];this.animation.add({targets:a,value:0,update:function(){r.updateLayerUniform(e,i)}},0)}},i=(e,t,i)=>{const a=e.layersList;if(void 0===t.backLayer){const r=i.getValues();r.alpha=0,t.backLayer=a.addLayerBeforeAt(r,t),t.backLayer.isBack=!0,e.dispose()}const r=`f${t.id}_alpha`,s=`f${t.backLayer.id}_alpha`,n=t.uniforms[r],o=t.backLayer.uniforms[s];this.animation.add({targets:n,value:0,update:function(){a.updateLayerUniformByLayer(t,r)}},0).add({targets:o,value:i.uniforms[`f${i.id}_alpha`].value,update:function(){a.updateLayerUniformByLayer(t.backLayer,s)}},0)},a=(e,i,a)=>{const r=e.layersList,s=`f${i.id}_mat`,n=`f${i.id}_texture`,o=i.uniforms[n].value,h=a.uniforms[`f${a.id}_texture`].value,l=i.uniforms[`f${i.id}_crop`],m=a.uniforms[`f${a.id}_crop`];if(l.value!==m.value&&(l.value=m.value,r.updateLayerUniformByLayer(i,`f${i.id}_crop`)),o.wrapS===h.wrapS&&o.wrapT===h.wrapT||(o.wrapS=h.wrapS,o.wrapT=h.wrapT,o.needsUpdate=!0,r.updateLayerUniform(i,n)),!1===o.matrix.equals(h.matrix)){const e={repeatX:o.repeat.x,repeatY:o.repeat.y,offsetX:o.offset.x,offsetY:o.offset.y};this.animation.add({targets:e,repeatX:h.repeat.x,repeatY:h.repeat.y,offsetX:h.offset.x,offsetY:h.offset.y,update:function(){o.repeat.set(e.repeatX,e.repeatY),o.offset.set(e.offsetX,e.offsetY),o.updateMatrix(),r.updateLayerUniformByLayer(i,s)}},0)}t(e,i,a,["alpha","mode"])},r=(e,i,a)=>{const r=e.layersList,s=i.uniforms[`f${i.id}_num`],n=a.uniforms[`f${a.id}_num`],o=`f${i.id}_steps`,h=`f${a.id}_steps`,l=i.uniforms[o],m=a.uniforms[h],d=`f${i.id}_colors`,c=`f${a.id}_colors`,u=i.uniforms[d],f=a.uniforms[c];if(s.value<=n.value){const e=u.value[s.value-1];for(let t=s.value;t<n.value;++t)l.value[t]=1,r.updateLayerUniformByLayer(i,d),u.value[t].set(e.x,e.y,e.z,e.w),r.updateLayerUniformByLayer(i,o);s.value!==n.value&&(s.value=n.value,r.updateLayerUniformByLayer(i,`f${i.id}_num`));for(let e=0;e<n.value;++e){const t=u.value[e],a=f.value[e];if(l.value[e]!==m.value[e]||!1===t.equals(a)){const s={value:l.value[e]};this.animation.add({targets:[s,t],value:m.value[e],x:a.x,y:a.y,z:a.z,w:a.w,update:function(){l.value[e]=s.value,r.updateLayerUniformByLayer(i,o),r.updateLayerUniformByLayer(i,d)}},0)}}}else{const e=[];for(let t=0;t<n.value;++t){const a=u.value[t],s=f.value[t];l.value[t]===m.value[t]&&!1!==a.equals(s)||e.push(new Promise(e=>{const n={value:l.value[t]};this.animation.add({targets:[n,a],value:m.value[t],x:s.x,y:s.y,z:s.z,w:s.w,update:function(){l.value[t]=n.value,r.updateLayerUniformByLayer(i,o),r.updateLayerUniformByLayer(i,d)},complete:function(){e(t)}},0)}))}const t=f.value[n.value-1];for(let a=n.value;a<s.value;++a){const s=u.value[a];l.value[a]===m.value[a]&&!1!==s.equals(t)||e.push(new Promise(e=>{const n={value:l.value[a]};this.animation.add({targets:[n,s],value:1,x:t.x,y:t.y,z:t.z,w:t.w,update:function(){l.value[a]=n.value,r.updateLayerUniformByLayer(i,o),r.updateLayerUniformByLayer(i,d)},complete:function(){e(a)}},0)}))}Promise.all(e).then(function(){s.value=n.value,r.updateLayerUniformByLayer(i,`f${i.id}_num`)})}t(e,i,a,["alpha","mode","gl_type","smooth","offset","morph","angle"])};function s(e,s){let n=e.layersList.head,o=0;for(;n;){if(!0===n.isBack){n=n.next;continue}const h=s.layersList[o++];if("texture"===n.type){const t=n.uniforms[`f${n.id}_texture`].value,r=h.uniforms[`f${h.id}_texture`].value;t.image===r.image?a(e,n,h):i(e,n,h)}else"gradient"===n.type?n.uniforms[`f${n.id}_gl_type`].value===h.uniforms[`f${h.id}_gl_type`].value?r(e,n,h):i(e,n,h):t(e,n,h);n=n.next}}if(Array.isArray(this.object.material))for(let t=0,i=this.object.material.length;t<i;++t)s(this.object.material[t],e.material[t]);else s(this.object.material,e.material)},animateCamera:function(e){this.object.isCamera&&this.object.zoom!==e.zoom&&this.animation.add({targets:this.object,zoom:e.zoom,update:()=>{this.object.updateProjectionMatrix()}},0)}},InteractionEvent.TYPE={MOUSE_DOWN:0,MOUSE_UP:1,MOUSE_HOVER:2,MOUSE_ENTER:3,MOUSE_LEAVE:4,KEY_DOWN:5,KEY_UP:6,START:7,LOOK_AT:8,SCROLL:9},InteractionEvent.ORDER=[InteractionEvent.TYPE.MOUSE_DOWN,InteractionEvent.TYPE.MOUSE_UP,InteractionEvent.TYPE.MOUSE_HOVER,InteractionEvent.TYPE.KEY_DOWN],InteractionEvent.prototype={constructor:InteractionEvent,get type(){return this._type},set type(e){this._type=e,e!==InteractionEvent.TYPE.KEY_DOWN&&e!==InteractionEvent.TYPE.KEY_UP&&(this.key=void 0)},newTarget:function(e){const t=new InteractionTarget;return t.object=e,e.interaction.states.length>0&&(t.state=e.interaction.states[e.interaction.states.length-1]),this.targets.push(t),Interaction.targets.add(t),t},addTarget:function(e,t){this.targets.splice(t,0,e),Interaction.targets.add(e)},removeTarget:function(e){Interaction.targets.delete(this.targets[e]),this.targets.splice(e,1)},dispatchReverse:function(){for(let e=0,t=this.targets.length;e<t;++e){const t=this.targets[e];void 0!==t.state&&t.object.interaction.reverse(t)}},dispatch:function(){for(let e=0,t=this.targets.length;e<t;++e){const t=this.targets[e];void 0!==t.state&&t.object.interaction.play(t)}},copy:function(e){return this.ui.isCollapsed=e.ui.isCollapsed,this},clone:function(){return new InteractionEvent(this.type,this.key).copy(this)},toJSON:function(e){const t={type:this._type,key:this.key,ui:{isCollapsed:this.ui.isCollapsed}};if(this.targets.length>0){t.targets=[];for(let i=0,a=this.targets.length;i<a;++i)t.targets.push(this.targets[i].toJSON(e))}return t},fromJSON:function(e,t,i){if(this._type=e.type,this.key=e.key,this.targets=[],this.ui={isCollapsed:e.ui.isCollapsed},void 0!==e.targets)for(let a=0,r=e.targets.length;a<r;++a)this.addTarget((new InteractionTarget).fromJSON(e.targets[a],t,i));return this}},InteractionState.prototype={constructor:InteractionState,update:function(e){this.updateMatrix(e),this.updateGeometry(e),this.updateMaterial(e),this.updateCamera(e)},updateCamera(e){e.isCamera&&(this.zoom=e.zoom)},updateMatrix:function(e){this.position.copy(e.position),this.rotation.copy(e.rotation),this.scale.copy(e.scale),this.hiddenMatrix.copy(e.hiddenMatrix)},updateGeometry:function(e){if(void 0!==e.geometry){const t=e.geometry.userData.parameters;this.geometry={width:t.width,height:t.height,depth:t.depth}}},updateMaterial:function(e){if(void 0!==e.material)if(!0===Array.isArray(e.material)){this.material=[];for(let t=0,i=e.material.length;t<i;++t){const i=[];let a=e.material[t].layersList.head;for(;a;)i.push(a.clone()),a=a.next;this.material.push({layersList:i})}}else{const t=[];let i=e.material.layersList.head;for(;i;)t.push(i.clone()),i=i.next;this.material={layersList:t}}},execute:function(e){if(e.position.copy(this.position),e.rotation.copy(this.rotation),e.scale.copy(this.scale),e.hiddenMatrix.copy(this.hiddenMatrix),void 0!==e.geometry){const t=e.geometry.userData.parameters;if(this.geometry.width!==t.width||this.geometry.height!==t.height||this.geometry.depth!==t.depth){const t=SPE[e.geometry.userData.type].buildFromGeometry(e.geometry,{width:this.geometry.width,height:this.geometry.height,depth:this.geometry.depth});e.updateGeometry(t)}}if(void 0!==e.material){const t=e.material;if(!0===Array.isArray(t))for(let e=0,i=this.material.length;e<i;++e){let i=t[e].layersList.head;const a=this.material[e].layersList;let r=0;for(;i;)i.copy(a[r++]),i=i.next;t[e].dispose()}else{let e=t.layersList.head;const i=this.material.layersList;let a=0;for(;e;)e.copyUniforms(i[a++]),e=e.next;t.dispose()}}e.isCamera&&(e.zoom=this.zoom,e.updateProjectionMatrix())},copy:function(e){if(this.name=e.name,this.position.copy(e.position),this.rotation.copy(e.rotation),this.scale.copy(e.scale),this.hiddenMatrix.copy(e.hiddenMatrix),void 0!==e.geometry&&(this.geometry={width:e.geometry.width,height:e.geometry.height,depth:e.geometry.depth}),void 0!==e.material)if(!0===Array.isArray(e.material)){this.material=[];for(let t=0,i=e.material.length;t<i;++t)this.material.push({layersList:e.material[t].layersList.map(e=>e.clone())})}else this.material={layersList:e.material.layersList.map(e=>e.clone())};return e.isCamera&&(this.zoom=e.zoom),this},clone:function(){return(new InteractionState).copy(this)},toJSON:function(e){const t={uuid:this.uuid,name:this.name,position:this.position.toArray(),rotation:this.rotation.toArray(),scale:this.scale.toArray(),hiddenMatrix:this.hiddenMatrix.toArray()};if(void 0!==this.geometry&&(t.geometry={width:this.geometry.width,height:this.geometry.height,depth:this.geometry.depth}),void 0!==this.material)if(!0===Array.isArray(this.material)){t.material=[];for(let i=0,a=this.material.length;i<a;++i)t.material.push({layersList:this.material[i].layersList.map(t=>t.toJSON(e))})}else t.material={layersList:this.material.layersList.map(t=>t.toJSON(e))};return this.isCamera&&(t.zoom=this.zoom),t},fromJSON:function(e,t){if(this.uuid=e.uuid,this.name=e.name,this.position.fromArray(e.position),void 0!==e.rotation)this.rotation.fromArray(e.rotation);else{const t=(new THREE.Quaternion).fromArray(e.quaternion);this.rotation.setFromQuaternion(t)}if(this.scale.fromArray(e.scale),this.hiddenMatrix.fromArray(e.hiddenMatrix),void 0!==e.geometry&&(this.geometry={width:e.geometry.width,height:e.geometry.height,depth:e.geometry.depth}),void 0!==e.material)if(!0===Array.isArray(e.material)){this.material=[];for(let i=0,a=e.material.length;i<a;++i)this.material.push({layersList:e.material[i].layersList.map(e=>SPE.CreateLayerFromJSON(e,t))})}else this.material={layersList:e.material.layersList.map(e=>SPE.CreateLayerFromJSON(e,t))};return this.zoom=void 0!==e.zoom?e.zoom:1,this}},InteractionTarget.EASING={LINEAR:0,EASE:1,EASE_IN:2,EASE_OUT:3,EASE_IN_OUT:4,CUBIC:5,SPRING:6},InteractionTarget.prototype={constructor:InteractionTarget,get sp_mass(){return this.springParameters.mass},set sp_mass(e){this.springParameters.mass=e},get sp_stiffness(){return this.springParameters.stiffness},set sp_stiffness(e){this.springParameters.stiffness=e},get sp_damping(){return this.springParameters.damping},set sp_damping(e){this.springParameters.damping=e},get sp_velocity(){return this.springParameters.velocity},set sp_velocity(e){this.springParameters.velocity=e},get interaction(){return void 0!==this._object?this._object.interaction:void 0},get object(){return this._object},set object(e){if(void 0!==e){const t=e.interaction.states;this.state=t.length>0?t[t.length-1]:void 0}else this.state=void 0;this._object=e},copy:function(e){return this.easing=e.easing,this.duration=e.duration,this.delay=e.delay,this.cubicControls=[...e.cubicControls],this.springParameters={mass:e.springParameters.mass,stiffness:e.springParameters.stiffness,damping:e.springParameters.damping,velocity:e.springParameters.velocity},this.repeat=e.repeat,this.cycle=e.cycle,this.rewind=e.rewind,this},clone:function(){return(new InteractionTarget).copy(this)},toJSON:function(){const e={easing:this.easing,duration:this.duration,delay:this.delay,cubicControls:this.cubicControls,springParameters:{mass:this.springParameters.mass,stiffness:this.springParameters.stiffness,damping:this.springParameters.damping,velocity:this.springParameters.velocity},repeat:this.repeat,cycle:this.cycle,rewind:this.rewind};return void 0!==this.object&&(e.object=this.object.uuid),void 0!==this.state&&(e.state=this.state.uuid),e},fromJSON:function(e,t,i){return void 0!==e.object&&(this._object=t[e.object]),void 0!==e.state&&(this.state=i[e.state]),this.easing=e.easing,this.duration=e.duration,this.delay=e.delay,this.cubicControls=[...e.cubicControls],this.repeat=e.repeat,this.cycle=e.cycle,this.rewind=void 0!==e.rewind&&e.rewind,void 0!==e.springControls?(this.springParameters.mass=e.springControls[0],this.springParameters.stiffness=e.springControls[1],this.springParameters.damping=e.springControls[2],this.springParameters.velocity=e.springControls[3]):(this.springParameters.mass=e.springParameters.mass,this.springParameters.stiffness=e.springParameters.stiffness,this.springParameters.damping=e.springParameters.damping,this.springParameters.velocity=e.springParameters.velocity),this}},InteractionStatesManager.prototype={updateObject(){void 0!==this.i.selectedState&&this.i.states[this.i.selectedState].updateMatrix(this.i.object)},updateCamera(){void 0!==this.i.selectedState&&(this.i.states[this.i.selectedState].updateMatrix(this.i.object),this.i.states[this.i.selectedState].updateCamera(this.i.object))},updateGeometry(){void 0!==this.i.selectedState&&(this.i.states[this.i.selectedState].updateMatrix(this.i.object),this.i.states[this.i.selectedState].updateGeometry(this.i.object))},updateSceneGraph(e){const t=new THREE.Matrix4,i=new THREE.Matrix4;e.updateWorldMatrix(!0,!1);for(let a=0,r=this.i.states.length;a<r;++a){const r=this.i.states[a];t.getInverse(e.matrixWorld),null!==this.i.object.parent&&(this.i.object.parent.updateWorldMatrix(!0,!1),t.multiply(this.i.object.parent.matrixWorld)),!0===this.i.object.isLight?(i.compose(r.position,r.quaternion,r.scale),i.premultiply(t),i.decompose(r.position,r.quaternion,r.scale)):r.hiddenMatrix.premultiply(t)}},updateMaterialLayer(e){if(void 0===this.i.selectedState)return;const t=this.i.object.userData.selectedMaterial;(void 0!==t?this.i.states[this.i.selectedState].material[t]:this.i.states[this.i.selectedState].material).layersList.find(t=>t.id===e.id).copy(e)},pushMaterialLayer(e){if(0!==this.i.states.length)if(!0===Array.isArray(this.i.object.material)){const t=this.i.object.userData.selectedMaterial;for(let i=0,a=this.i.states.length;i<a;++i){const a=e.clone();this.i.selectedState!==i&&(a.uniforms[`f${a.id}_alpha`].value=0),this.i.states[i].material[t].layersList.push(a)}}else for(let t=0,i=this.i.states.length;t<i;++t){const i=e.clone();this.i.selectedState!==t&&(i.uniforms[`f${i.id}_alpha`].value=0),this.i.states[t].material.layersList.push(i)}},popMaterialLayer(){if(0!==this.i.states.length)if(!0===Array.isArray(this.i.object.material)){const e=this.i.object.userData.selectedMaterial;for(let t=0,i=this.i.states.length;t<i;++t)this.i.states[t].material[e].layersList.pop()}else for(let e=0,t=this.i.states.length;e<t;++e)this.i.states[e].material.layersList.pop()},removeMaterialLayer(e){if(0===this.i.states.length)return;let t=[];if(!0===Array.isArray(this.i.object.material))for(let i=0,a=this.i.states.length;i<a;++i){const a=this.i.object.userData.selectedMaterial,r=this.i.states[i].material[a];t.push({layer:r.layersList[e]}),r.layersList.splice(e,1)}else for(let i=0,a=this.i.states.length;i<a;++i){const a=this.i.states[i].material;t.push({layer:a.layersList[e]}),a.layersList.splice(e,1)}return{states:t,pos:e}},restoreMaterialLayerRemoved(e){if(0!==this.i.states.length)if(!0===Array.isArray(this.i.object.material))for(let t=0,i=this.i.states.length;t<i;++t){const i=this.i.object.userData.selectedMaterial;this.i.states[t].material[i].layersList.splice(e.pos,0,e.states[t].layer)}else for(let t=0,i=this.i.states.length;t<i;++t){this.i.states[t].material.layersList.splice(e.pos,0,e.states[t].layer)}},changeMaterialLayer(e){if(0===this.i.states.length)return;let t,i=[];if(!0===Array.isArray(this.i.object.material)){const a=this.i.object.userData.selectedMaterial,r=this.i.states[this.i.selectedState].material[a].layersList;for(let i=0,a=r.length;i<a;++i)if(r[i].id===e.id){t=i;break}for(let r=0,s=this.i.states.length;r<s;++r){const s=this.i.states[r].material[a].layersList[t],n=e.clone();this.i.selectedState!==r&&(n.uniforms[`f${n.id}_alpha`].value=s.uniforms[`f${s.id}_alpha`].value),this.i.states[r].material[a].layersList[t]=n,i.push({layer:s})}}else{const a=this.i.states[this.i.selectedState].material.layersList;for(let i=0,r=a.length;i<r;++i)if(a[i].id===e.id){t=i;break}for(let a=0,r=this.i.states.length;a<r;++a){const r=this.i.states[a].material.layersList[t],s=e.clone();this.i.selectedState!==a&&(s.uniforms[`f${s.id}_alpha`].value=r.uniforms[`f${r.id}_alpha`].value),this.i.states[a].material.layersList[t]=s,i.push({layer:r})}}return{states:i,pos:t}},restoreMaterialLayerChanged(e){if(0!==this.i.states.length)if(!0===Array.isArray(this.i.object.material)){const t=this.i.object.userData.selectedMaterial;for(let i=0,a=this.i.states.length;i<a;++i)this.i.states[i].material[t].layersList[e.pos]=e.states[i].layer}else for(let t=0,i=this.i.states.length;t<i;++t)this.i.states[t].material.layersList[e.pos]=e.states[t].layer},moveMaterialLayer(e,t){if(0!==this.i.states.length)if(!0===Array.isArray(this.i.object.material)){const i=this.i.object.userData.selectedMaterial;for(let a=0,r=this.i.states.length;a<r;++a){const r=this.i.states[a].material[i].layersList,s=r[e];r[e]=r[t],r[t]=s}}else for(let i=0,a=this.i.states.length;i<a;++i){const a=this.i.states[i].material.layersList,r=a[e];a[e]=a[t],a[t]=r}},restoreMaterialLayerMoved(e,t){this.moveMaterialLayer(e,t)},setMaterialLayers(e){const t=[];if(Array.isArray(this.i.object.material)){const i=this.i.object.userData.selectedMaterial;for(let a=0,r=this.i.states.length;a<r;++a){const r=this.i.states[a].material[i];t.push({layersList:r.layersList});let s=e.head;for(r.layersList=[];void 0!==s;)r.layersList.push(s.clone()),s=s.next}}else for(let i=0,a=this.i.states.length;i<a;++i){const a=this.i.states[i].material;t.push({layersList:a.layersList});let r=e.head;for(a.layersList=[];void 0!==r;)a.layersList.push(r.clone()),r=r.next}return{states:t}},restoreMaterialLayersSet(e){if(Array.isArray(this.i.object.material)){const t=object.userData.selectedMaterial;for(let i=0,a=this.i.states.length;i<a;++i)this.i.states[i].material[t].layersList=e.states[i].layersList}else for(let t=0,i=this.i.states.length;t<i;++t)this.i.states[t].material.layersList=e.states[t].layersList}},SPE.ConeGeometry=new function(){this.build=function({width:e=100,height:t=e,depth:i=e,radialSegments:a=32,heightSegments:r=32,openEnded:s,thetaStart:n,thetaLength:o=360,cornerRadiusTop:h=0,cornerRadiusBottom:l=0,cornerSegments:m=8}){let d;return e=Math.abs(e),t=Math.abs(t),i=Math.abs(i),(d=h>0||l>0||o<360?new SPE.CylinderGeometry.RoundedCylinderBufferGeometry(0,e/2,t,a,r,s,n,o*Math.PI/180,h,l,m,0,!0):new THREE.ConeBufferGeometry(e/2,t,a,r,s)).scale(1,1,i/e),d.userData={type:"ConeGeometry",parameters:{width:e,height:t,depth:i,radialSegments:a,heightSegments:r,openEnded:s,thetaStart:n,thetaLength:o,cornerRadiusTop:h,cornerRadiusBottom:l,cornerSegments:m}},d},this.buildFromGeometry=function(e,{width:t=e.userData.parameters.width,height:i=e.userData.parameters.height,depth:a=e.userData.parameters.depth,radialSegments:r=e.userData.parameters.radialSegments,heightSegments:s=e.userData.parameters.heightSegments,openEnded:n=e.userData.parameters.openEnded,thetaStart:o=e.userData.parameters.thetaStart,thetaLength:h=e.userData.parameters.thetaLength,cornerRadiusTop:l=e.userData.parameters.cornerRadiusTop,cornerRadiusBottom:m=e.userData.parameters.cornerRadiusBottom,cornerSegments:d=e.userData.parameters.cornerSegments}){return this.build({width:t,height:i,depth:a,radialSegments:r,heightSegments:s,openEnded:n,thetaStart:o,thetaLength:h,cornerRadiusTop:l,cornerRadiusBottom:m,cornerSegments:d})}},SPE.CubeGeometry=new function(){this.build=function({width:e=100,height:t=e,depth:i=e,widthSegments:a=1,heightSegments:r=1,depthSegments:s=1,cornerRadius:n=0,cornerSegments:o=8}){let h;return e=Math.abs(e),t=Math.abs(t),i=Math.abs(i),(h=0==n?new THREE.BoxBufferGeometry(e,t,i,a,r,s):new RoundedBoxBufferGeometry(e,t,i,a,r,s,n,o)).userData={type:"CubeGeometry",parameters:{width:e,height:t,depth:i,widthSegments:a,heightSegments:r,depthSegments:s,cornerRadius:n,cornerSegments:o}},h},this.buildFromGeometry=function(e,{width:t=e.userData.parameters.width,height:i=e.userData.parameters.height,depth:a=e.userData.parameters.depth,widthSegments:r=e.userData.parameters.widthSegments,heightSegments:s=e.userData.parameters.heightSegments,depthSegments:n=e.userData.parameters.depthSegments,cornerRadius:o=e.userData.parameters.cornerRadius,cornerSegments:h=e.userData.parameters.cornerSegments}){return this.build({width:t,height:i,depth:a,widthSegments:r,heightSegments:s,depthSegments:n,cornerRadius:o,cornerSegments:h})}};const pi2=Math.PI/2;class RoundedBoxBufferGeometry extends THREE.BufferGeometry{constructor(e=1,t=1,i=1,a=1,r=1,s=1,n=0,o=4){const h=THREE.Vector3;super(),this.type="BoxBufferGeometry",this.parameters={width:e,height:t,depth:i,widthSegments:a,heightSegments:r,depthSegments:s,cornerRadius:n,cornerSegments:o};const l=this;a=Math.floor(a),r=Math.floor(r),s=Math.floor(s),o=Math.floor(o),n=Math.min(n,e/2,t/2,i/2);const m=[],d=[],c=[],u=[];let f=0,p=0;function E(e,t,i,a,r,s,o,E,_,g,y){const v=(s-2*n)/_,S=(o-2*n)/g,T=s/2-n,R=o/2-n,I=E/2,w=_+1,b=g+1;let L=0,x=0;const M=new h;for(let s=0;s<b;s++){const n=s*S-R;for(let o=0;o<w;o++){const h=o*v-T;M[e]=h*a,M[t]=n*r,M[i]=I,d.push(M.x,M.y,M.z),M[e]=0,M[t]=0,M[i]=E>0?1:-1,c.push(M.x,M.y,M.z),u.push(o/_),u.push(1-s/g),L+=1}}for(let e=0;e<g;e++)for(let t=0;t<_;t++){const i=f+t+w*e,a=f+t+w*(e+1),r=f+(t+1)+w*(e+1),s=f+(t+1)+w*e;m.push(i,a,s),m.push(a,r,s),x+=6}l.addGroup(p,x,y),p+=x,f+=L}function _(e,t,i,a,r,s,E,_,g,y,v){const S=(E-2*n)/y,T=E/2-n,R=_/2-n,I=g/2,w=y+1;let b=0,L=0;const x=new h,M=new h;for(let h=0;h<o+1;h++){const l=h/o*pi2,m=Math.sin(l)*n,f=(1-Math.cos(l))*n,p=Math.sin(l),E=Math.cos(l);x[t]=(R+m)*r,x[i]=(I-f)*s,M[e]=0,M[t]=p*Math.sign(x[t]),M[i]=E*Math.sign(x[i]);for(let t=0;t<w;t++){const i=t*S-T;x[e]=i*a,d.push(x.x,x.y,x.z),c.push(M.x,M.y,M.z),u.push(t/y),u.push(0),b+=1}}for(let e=0;e<o;e++)for(let t=0;t<y;t++){const i=f+t+w*e,a=f+t+w*(e+1),r=f+(t+1)+w*(e+1),s=f+(t+1)+w*e;m.push(i,a,s),m.push(a,r,s),L+=6}l.addGroup(p,L,v),p+=L,f+=b}function g(a,r,s){const l=new h,p=new h(e/2,t/2,i/2);p.subScalar(n);const E=[],_=a*r*s>0?function(e,t,i){m.push(e,t,i)}:function(e,t,i){m.push(e,i,t)};for(let e=0;e<=o;e++){const t=[],i=pi2*(1-e/o),h=Math.cos(i),m=Math.sin(i);let _=0;for(var g=0;g<=e;g++){const i=Math.cos(_),o=Math.sin(_);l.x=h*i,l.y=m,l.z=h*o;const E=p.clone().addScaledVector(l,n);d.push(a*E.x,r*E.y,s*E.z),c.push(a*l.x,r*l.y,s*l.z),u.push(0,0),t.push(f++),_+=pi2/e}E.push(t)}const y=E.length-1;for(let e=0;e<y;e++){const t=E[e],i=E[e+1],a=t.length-1;_(t[0],i[1],i[0]);for(let e=1;e<=a;e++)_(t[e-1],t[e],i[e]),_(t[e],i[e+1],i[e])}}E("z","y","x",-1,-1,i,t,e,s,r,0),E("z","y","x",1,-1,i,t,-e,s,r,1),E("x","z","y",1,1,e,i,t,a,s,2),E("x","z","y",1,-1,e,i,-t,a,s,3),E("x","y","z",1,-1,e,t,i,a,r,4),E("x","y","z",-1,-1,e,t,-i,a,r,5),n>0&&(_("z","y","x",-1,-1,1,i,t,e,s,0),_("z","y","x",1,-1,-1,i,t,e,s,1),_("z","y","x",-1,1,-1,i,t,e,s,1),_("z","y","x",1,1,1,i,t,e,s,0),_("x","y","z",-1,-1,-1,e,t,i,a,0),_("x","y","z",1,-1,1,e,t,i,a,1),_("x","y","z",-1,1,1,e,t,i,a,0),_("x","y","z",1,1,-1,e,t,i,a,1),_("y","x","z",-1,-1,1,t,e,i,r,0),_("y","x","z",1,-1,-1,t,e,i,r,1),_("y","x","z",1,1,1,t,e,i,r,1),_("y","x","z",-1,1,-1,t,e,i,r,0),g(1,1,1),g(-1,1,1),g(1,-1,1),g(-1,-1,1),g(1,1,-1),g(-1,1,-1),g(1,-1,-1),g(-1,-1,-1)),this.setIndex(m),this.setAttribute("position",new THREE.Float32BufferAttribute(d,3)),this.setAttribute("normal",new THREE.Float32BufferAttribute(c,3)),this.setAttribute("uv",new THREE.Float32BufferAttribute(u,2))}}function two2three(e,t,i){i.x=e.x*t.x,i.y=e.y,i.z=e.x*t.y}function flip(e){return new THREE.Vector2(e.y,-e.x)}SPE.CylinderGeometry=new function(){this.build=function({width:e=100,height:t=e,depth:i=e,radiusTop:a=e/2,radiusBottom:r=e/2,radialSegments:s=64,heightSegments:n=1,openEnded:o=!1,thetaStart:h,thetaLength:l=360,cornerRadius:m=0,cornerSegments:d=8,hollow:c=0}){e=Math.abs(e),t=Math.abs(t),i=Math.abs(i);let u=e/2;if(a===r)a=u,r=u;else if(a>r)r=r*u/(a=u);else a=a*u/r,r=u;let f=new RoundedCylinderBufferGeometry(a,r,t,s,n,o,h,l*Math.PI/180,m,m,d,c);return f.scale(1,1,i/e),f.userData={type:"CylinderGeometry",parameters:{width:e,height:t,depth:i,radiusTop:a,radiusBottom:r,radialSegments:s,heightSegments:n,openEnded:o,thetaStart:h,thetaLength:l,cornerRadius:m,cornerSegments:d,hollow:c}},f},this.buildFromGeometry=function(e,{width:t=e.userData.parameters.width,height:i=e.userData.parameters.height,depth:a=e.userData.parameters.depth,radiusTop:r=e.userData.parameters.radiusTop,radiusBottom:s=e.userData.parameters.radiusBottom,radialSegments:n=e.userData.parameters.radialSegments,heightSegments:o=e.userData.parameters.heightSegments,openEnded:h=e.userData.parameters.openEnded,thetaStart:l=e.userData.parameters.thetaStart,thetaLength:m=e.userData.parameters.thetaLength,cornerRadius:d=e.userData.parameters.cornerRadius,cornerSegments:c=e.userData.parameters.cornerSegments,hollow:u=e.userData.parameters.hollow}){return this.build({width:t,height:i,depth:a,radiusTop:r,radiusBottom:s,radialSegments:n,heightSegments:o,openEnded:h,thetaStart:l,thetaLength:m,cornerRadius:d,cornerSegments:c,hollow:u})}};class RoundedCylinderBufferGeometry extends THREE.BufferGeometry{constructor(e,t,i,a,r,s,n,o,h,l,m,d,c=!1){super(),this.type="RoundedCylinderBufferGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:i,radialSegments:a,heightSegments:r,openEnded:s,thetaStart:n,thetaLength:o,cornerRadius:h,cornerRadius:l,cornerSegments:m,hollow:d};var u=THREE.Vector2,f=THREE.Vector3,p=THREE.Float32BufferAttribute;e=void 0!==e?e:1,t=void 0!==t?t:1,i=i||1,a=Math.floor(a)||8,r=Math.floor(r)||1,s=void 0!==s&&s,n=void 0!==n?n:0,o=void 0!==o?o:2*Math.PI,s&&(h=0,l=0);const E=[],_=[],g=[],y=[];let v=0;const S=i/2;const T=new f,R=new f;c&&0==e&&(e=h),c&&0==t&&(t=l);let I=new u(e,S),w=new u(t,-S),b=null,L=null,x=null,M=null,P=I.clone().sub(w),A=0,$=0,O=0;d>0&&(A=Math.min(e,t)*(1-d),$=e-A,O=t-A);const U=I.clone();U.x-=A;const D=Math.PI-P.angle(),C=P.angle(),H=Math.tan(C/2),G=Math.tan(D/2),N=H+G,B=d?N:G,z=d?N:H;if(h=Math.min(h,(e-$)/B,P.length()/N),l=Math.min(l,(t-O)/z,P.length()/N),h>0){const e=h/H;b=I.clone().sub(new u(e,h)),d&&((x=b.clone()).x-=A-N*h),I.sub(P.clone().setLength(e))}if(l>0){const e=l/G;L=w.clone().sub(new u(e,-l)),w.add(P.clone().setLength(e)),d&&((M=L.clone()).x-=A-N*l,U.sub(P.clone().setLength(e)))}const Y=(P=I.clone().sub(w)).length()<.5,V=[];for(let m=0;m<=a;m++){const c=[],f=m/a,p=f*o+n,E=new u(Math.sin(p),Math.cos(p));M?(F(c,f,E,D,l,M,-1,!0),F(c,f,E,C,l,L,-1,!1)):L?(j(c,E,L.x,0,-1),F(c,f,E,C,l,L,-1,!1)):s||j(c,E,t,O,-1);const S=flip(P).normalize();if(two2three(S,E,T),!Y)for(let e=0;e<=r;e++){const t=e/r,a=P.clone().multiplyScalar(t).add(w);two2three(a,E,R),_.push(R.x,R.y,R.z),g.push(T.x,T.y,T.z),y.push(f,.5+R.y/i),c.push(v++)}if(x?(F(c,f,E,D,h,b,1,!1),F(c,f,E,C,h,x,1,!0)):b?(F(c,f,E,D,h,b,1,!1),j(c,E,b.x,0,1)):s||j(c,E,e,$,1),d&&!Y){const e=flip(P).multiplyScalar(-1).normalize();two2three(e,E,T);for(let e=0;e<=r;e++){const t=e/r,a=P.clone().multiplyScalar(-t).add(U);two2three(a,E,R),_.push(R.x,R.y,R.z),g.push(T.x,T.y,T.z),y.push(f,.5+R.y/i),c.push(v++)}}d&&!s&&c.push(c[0]),V.push(c)}for(let e=0;e<V.length-1;e++)for(let t=0;t<V[0].length-1;t++){if(s&&d&&t==r)continue;const i=V[e][t],a=V[e+1][t],n=V[e+1][t+1],o=V[e][t+1],h=_[3*n+0],l=_[3*n+2];E.push(i,a,o),0==h&&0==l||E.push(a,n,o)}function F(e,t,a,r,s,n,o,h){for(let l=0;l<m+1;l++){const d=l/m;let c=o<0?d:1-d;h&&(c-=1),c*=r;const f=new u(Math.sin(c),Math.cos(c)*o),p=f.clone().multiplyScalar(s).add(n);two2three(p,a,R),_.push(R.x,R.y,R.z),two2three(f,a,T),g.push(T.x,T.y,T.z),y.push(t,.5+R.y/i),e.push(v++)}}function j(e,t,i,a,r){const s=new f,n=new u,o=[i,a];r<0&&o.reverse();for(const i of o)n.set(i,S*r),two2three(n,t,s),_.push(s.x,s.y,s.z),g.push(0,r,0),y.push(.5,.5),e.push(v++)}function k(i,a,r){const s=new u(Math.sin(r),Math.cos(r)),n=new u(-Math.cos(r),Math.sin(r)),o=new f,h=i<0?(e,t,i)=>E.push(e,t,i):(e,t,i)=>E.push(e,i,t),l=new u((e+t+$+O)/4,0);two2three(l,s,o),_.push(o.x,o.y,o.z),g.push(n.x,0,n.y),y.push(.5,.5);const m=v++;for(const e of a){const t=_.slice(3*e,3*e+3);_.push(...t),g.push(n.x,0,n.y);const i=y.slice(2*e,2*e+2);y.push(...i),v++}for(let e=m+1;e<v-1;e++)h(m,e,e+1);h(m,v-1,m+1)}o<2*Math.PI&&(k(-1,V[0],n),k(1,V[V.length-1],n+o)),this.setIndex(E),this.setAttribute("position",new p(_,3)),this.setAttribute("normal",new p(g,3)),this.setAttribute("uv",new p(y,2))}}function two2three(e,t,i){i.x=e.x*t.x,i.y=e.y,i.z=e.x*t.y}function offset3d(e,t,i,a,r,s){const n=t.clone().sub(e),o=i.clone().sub(e),h=n.angleTo(o);if(n.normalize(),o.normalize(),a===r){const t=n.add(o).normalize();s.copy(e).addScaledVector(t,a/Math.sin(h/2))}else{const t=n.angleTo(o);s.copy(e),s.addScaledVector(n,r/Math.sin(t)),s.addScaledVector(o,a/Math.sin(t))}}function projectOntoLine(e,t,i){const a=e.clone().sub(t),r=i.clone().sub(t);return a.projectOnVector(r),a.add(t)}function intersectLines(e,t,i,a){const r=e.clone().sub(i),s=a.clone().sub(i),n=t.clone().sub(e);if(s.manhattanLength()<=3*Number.Epsilon||n.manhattanLength()<=3*Number.Epsilon)return!1;const o=r.dot(s),h=s.dot(n),l=r.dot(n),m=n.dot(n),d=s.dot(s),c=m*d-h*h;if(Math.abs(c)<=Number.Epsilon)return!1;const u=(o*h-l*d)/c,f=(o+h*u)/d,p=e.clone().addScaledVector(n,u),E=i.clone().addScaledVector(s,f);return!(p.distanceToSquared(E)>Number.Epsilon)&&p}SPE.CylinderGeometry.RoundedCylinderBufferGeometry=RoundedCylinderBufferGeometry,SPE.EllipseGeometry=new function(){this.build=function({width:e=100,height:t=e,spikes:i=128,angle:a=360,innerRadius:r=0}){let s;if(r>0){let n=.5*e,o=r*n/100;(s=new THREE.RingBufferGeometry(o,n,i,1,Math.PI/2,a*Math.PI/180)).scale(1,Math.abs(t)/Math.abs(e),1)}else{let r=!0,n=.5*(e=Math.abs(e)),o=.5*(t=Math.abs(t)),h=0,l=0,m=a*Math.PI/180*(r?-1:1)/i,d=new THREE.Shape;for(let e=0;e<=i;e++){let t=m*e,i=h+Math.sin(t)*n,a=l+Math.cos(t)*o;d.lineTo(i,a)}360===a&&(d.curves=d.curves.slice(1)),s=new THREE.ShapeBufferGeometry(d),SPE.Math.fixUvs(s,e,t)}return s.userData={type:"EllipseGeometry",parameters:{width:e,height:t,depth:0,spikes:i,angle:a,innerRadius:r}},s},this.buildFromGeometry=function(e,{width:t=e.userData.parameters.width,height:i=e.userData.parameters.height,spikes:a=e.userData.parameters.spikes,angle:r=e.userData.parameters.angle,innerRadius:s=e.userData.parameters.innerRadius}){return this.build({width:t,height:i,spikes:a,angle:r,innerRadius:s})}},SPE.IcosahedronGeometry=new function(){this.build=function({width:e=100,height:t=e,depth:i=e,detail:a=0}){e=Math.abs(e),t=Math.abs(t),i=Math.abs(i);let r=new THREE.IcosahedronBufferGeometry(.5*e,a);return r.scale(1,t/e,i/e),r.userData={type:"IcosahedronGeometry",parameters:{width:e,height:t,depth:i,detail:a}},r},this.buildFromGeometry=function(e,{width:t=e.userData.parameters.width,height:i=e.userData.parameters.height,depth:a=e.userData.parameters.depth,detail:r=e.userData.parameters.detail}){return this.build({width:t,height:i,depth:a,detail:r})}},SPE.PolygonGeometry=new function(){this.build=function({width:e=100,height:t=e,spikes:i=5,cornerRadius:a=0,extrudeDepth:r=0,extrudeBevelSize:s=0,extrudeBevelSegments:n=1}){let o,h=.5*(e=Math.abs(e)),l=.5*(t=Math.abs(t)),m=2*Math.PI/i,d=new THREE.Shape;for(let e=0;e<=i;e++){let t=m*e,i=0+Math.sin(t)*h,a=0+Math.cos(t)*l;d.lineTo(i,a)}return 0!==a&&SPE.Geometry.Utils.roundShapePolygon(d,d.getPoints(),a),(o=r>0?new THREE.ExtrudeBufferGeometry(d,{curveSegments:64,steps:1,depth:r,bevelEnabled:!0,bevelThickness:s,bevelSize:s,bevelOffset:0,bevelSegments:n}):new THREE.ShapeBufferGeometry(d,32)).userData={type:"PolygonGeometry",parameters:{width:e,height:t,depth:0,spikes:i,cornerRadius:a,extrudeDepth:r,extrudeBevelSize:s,extrudeBevelSegments:n}},SPE.Math.fixUvs(o,e,t),o},this.buildFromGeometry=function(e,{width:t=e.userData.parameters.width,height:i=e.userData.parameters.height,spikes:a=e.userData.parameters.spikes,cornerRadius:r=e.userData.parameters.cornerRadius,extrudeDepth:s=e.userData.parameters.extrudeDepth,extrudeBevelSize:n=e.userData.parameters.extrudeBevelSize,extrudeBevelSegments:o=e.userData.parameters.extrudeBevelSegments}){return this.build({width:t,height:i,spikes:a,cornerRadius:r,extrudeDepth:s,extrudeBevelSize:n,extrudeBevelSegments:o})}},SPE.PyramidGeometry=new function(){this.build=function({width:e=100,height:t=e,depth:i=e,radialSegments:a=4,heightSegments:r=1,openEnded:s,cornerRadius:n=0,cornerSegments:o=8}){e=Math.abs(e),t=Math.abs(t),i=Math.abs(i);let h=new RoundedPyramidBufferGeometry(.5*e,t,a,r,s,n,o);return h.scale(1,1,i/e),h.userData={type:"PyramidGeometry",parameters:{width:e,height:t,depth:i,radialSegments:a,heightSegments:r,openEnded:s,cornerRadius:n,cornerSegments:o}},h},this.buildFromGeometry=function(e,{width:t=e.userData.parameters.width,height:i=e.userData.parameters.height,depth:a=e.userData.parameters.depth,radialSegments:r=e.userData.parameters.radialSegments,heightSegments:s=e.userData.parameters.heightSegments,openEnded:n=e.userData.parameters.openEnded,cornerRadius:o=e.userData.parameters.cornerRadius,cornerSegments:h=e.userData.parameters.cornerSegments}){return this.build({width:t,height:i,depth:a,radialSegments:r,heightSegments:s,openEnded:n,cornerRadius:o,cornerSegments:h})}};class RoundedPyramidBufferGeometry extends THREE.BufferGeometry{constructor(e=.5,t=1,i=4,a=1,r=!1,s=0,n=4){const o=THREE.Vector2,h=THREE.Vector3;super(),this.type="RoundedPyramidBufferGeometry",this.parameters={radius:e,height:t,radialSegments:i,heightSegments:a,openEnded:r,cornerRadius:s,cornerSegments:n};i=Math.floor(Math.max(3,i)),a=Math.floor(a),n=Math.floor(n);const l=[],m=[],d=[],c=[];let u=0;const f=t/2,p=Math.PI/i,E=e*Math.cos(Math.PI/i),_=2*Math.PI/i,g=(i-2)*Math.PI/i,y=Math.PI-g,v=new h(0,-f,0),S=new h(0,f,0),T=new o(e,-f),R=new o(E,-f),I=(new o).copy(S).sub(R),w=(new o).copy(S).sub(T),b=new o(I.y,-I.x).normalize(),L=new o(w.y,-w.x).normalize(),x=e*Math.cos(Math.PI/i)*Math.tan((Math.PI-I.angle())/2)-1e-8;let M;s=Math.min(s,x);{const e=new h(b.x,b.y,0),t=new h(Math.cos(_)*e.x,e.y,Math.sin(_)*e.x);M=e.angleTo(t)}const P=s/Math.tan((Math.PI-I.angle())/2),A=s/Math.tan((Math.PI-M)/2),$=new h;if(!r){m.push(v.x,v.y,v.z),d.push(0,-1,0),c.push(0,0);const e=u++,t=[],a=T.clone(),r=P/Math.cos(Math.PI/i);a.x-=r;for(let e=0;e<i;e++){const r=e/i*Math.PI*2+p,s=new o(Math.sin(r),Math.cos(r));two2three(a,s,$),m.push($.x,$.y,$.z),d.push(0,-1,0),c.push(0,0),t.push(u++)}for(let i=0;i<t.length;i++)l.push(t[i],e,t[(i+1)%t.length])}const O=[];{const e=new h,t=new h,a=new h,r=new h,f=new h,E=new h;for(let _=0;_<i;_++){const g=_/i*Math.PI*2+p,y=(_+.5)/i*Math.PI*2+p,R=(_+1)/i*Math.PI*2+p,w=new o(Math.sin(g),Math.cos(g)),x=new o(Math.sin(y),Math.cos(y)),$=new o(Math.sin(R),Math.cos(R));two2three(T,w,t),two2three(T,$,a),two2three(b,x,e),offset3d(S,t,a,A,A,r),m.push(r.x,r.y,r.z),offset3d(t,S,a,A,P,f),m.push(f.x,f.y,f.z),offset3d(a,t,S,P,A,E),m.push(E.x,E.y,E.z),d.push(e.x,e.y,e.z),d.push(e.x,e.y,e.z),d.push(e.x,e.y,e.z),c.push(0,0),c.push(0,0),c.push(0,0);const H=u++,G=u++,N=u++;if(l.push(H,G,N),s>0){{const e=t.clone().add(a).multiplyScalar(.5),i=S.clone().sub(e).normalize(),r=v.clone().sub(e).normalize().add(i).normalize().multiplyScalar(-1);D(e,E.clone().sub(f),r,I.angle())}let o,p;{const e=new h;two2three(L,$,e);let t=E.clone().add(r).multiplyScalar(.5);t=projectOntoLine(t,a,S);const i=E.clone().sub(r);[o,p]=D(t,i,e,M,r.y)}{const e=o,t=e.clone().setY(0).normalize(),i=new h(0,-1,0),a=t.clone().cross(i);C(e,t,i,a)}O.concat(p);{const t=I.angle(),a=Math.PI-t,r=S.clone();r.y-=s/Math.sin(t-Math.PI/2);new h;const o=new h,f=[];for(let t=0;t<n;t++){const h=[],l=Math.PI/2-a*t/n,p=Math.cos(l),E=Math.sin(l);let _=y;for(var U=0;U<=t;U++){const a=Math.cos(_),n=Math.sin(_);e.x=p*n,e.y=E,e.z=p*a,o.copy(r).addScaledVector(e,s),m.push(o.x,o.y,o.z),d.push(e.x,e.y,e.z),c.push(0,0),h.push(u++),_+=2*Math.PI/t/i}f.push(h)}p.reverse(),f.push(p);const E=f.length-1;for(let e=0;e<E;e++){const t=f[e],i=f[e+1],a=t.length-1;l.push(i[1],t[0],i[0]);for(let e=1;e<=a;e++)l.push(t[e],t[e-1],i[e]),l.push(i[e+1],t[e],i[e])}}}}}function D(e,t,i,a,r){const o=-a/2,f=(Math.PI-a)/2,p=t.clone().normalize().cross(i);e.addScaledVector(i,-s/Math.sin(f));const E=new h,_=new h,g=u,y=[];for(let h=0;h<=n;h++){const l=o+h/n*a;_.set(0,0,0),_.addScaledVector(p,Math.sin(l)),_.addScaledVector(i,Math.cos(l));for(let i=0;i<=1;i++){const a=i/1-.5;if(E.copy(e),E.addScaledVector(t,a),E.addScaledVector(_,s),null!=r){const e=Math.max(0,E.y-r);E.addScaledVector(t,-e/t.y)}m.push(E.x,E.y,E.z),d.push(_.x,_.y,_.z),c.push(0,0),0===i&&y.push(u),u++}}for(let e=0;e<n;e++)for(let t=0;t<1;t++){const i=g+t+2*e,a=i+2,r=a+1,s=i+1;l.push(i,a,s),l.push(a,r,s)}return[e.clone().addScaledVector(t,.5),y]}function C(e,t,i,a){const r=Math.PI/2,o=w.angle()-r,f=[],p=new h,E=new h;for(let h=0;h<=n;h++){const l=[],g=h/n;for(var _=0;_<=h;_++){const n=((h?_/h:0)-.5)*y,f=Math.cos(n),v=Math.sin(n),S=(r+Math.atan(Math.tan(o)*f))*g,T=Math.cos(S),R=Math.sin(S);p.set(0,0,0),p.addScaledVector(t,R*f),p.addScaledVector(i,T),p.addScaledVector(a,R*v),E.copy(e).addScaledVector(p,s),m.push(E.x,E.y,E.z),d.push(p.x,p.y,p.z),c.push(0,0),l.push(u++)}f.push(l)}const g=f.length-1;for(let e=0;e<g;e++){const t=f[e],i=f[e+1],a=t.length-1;l.push(t[0],i[1],i[0]);for(let e=1;e<=a;e++)l.push(t[e-1],t[e],i[e]),l.push(t[e],i[e+1],i[e])}}this.setIndex(l),this.setAttribute("position",new THREE.Float32BufferAttribute(m,3)),this.setAttribute("normal",new THREE.Float32BufferAttribute(d,3)),this.setAttribute("uv",new THREE.Float32BufferAttribute(c,2))}}SPE.RectangleGeometry=new function(){this.build=function({width:e=100,height:t=e,cornerRadius:i=[0,0,0,0],cornerType:a=1,enabledIndieCorners:r=!1,extrudeDepth:s=0,extrudeBevelSize:n=0,extrudeBevelSegments:o=1}){e=Math.abs(e),t=Math.abs(t);let h={x:.5*e,y:.5*t},l={x:-h.x,y:-h.y},m={x:h.x,y:h.y};function d(i,a,r){return a>e&&r>t?Math.min(i*e/a,i*t/r):a>e?i*e/a:r>t?i*t/r:i}var c=[];c[0]=0===i[0]?0:d(i[0],i[0]+i[3],i[0]+i[1]),c[1]=0===i[1]?0:d(i[1],i[1]+i[2],i[1]+i[0]),c[2]=0===i[2]?0:d(i[2],i[2]+i[1],i[2]+i[3]),c[3]=0===i[3]?0:d(i[3],i[3]+i[0],i[3]+i[2]);let u,f=l.x,p=m.x,E=m.y,_=l.y,g=new THREE.Shape;if(g.moveTo(f,E-c[0]),1==a)i[0]>0&&g.quadraticCurveTo(f,E,f+c[0],E),g.lineTo(p-c[1],E),i[1]>0&&g.quadraticCurveTo(p,E,p,E-c[1]),g.lineTo(p,_+c[2]),i[2]>0&&g.quadraticCurveTo(p,_,p-c[2],_),g.lineTo(f+c[3],_),i[3]>0&&g.quadraticCurveTo(f,_,f,_+c[3]),g.lineTo(f,E-c[0]);else{let e=4*(Math.SQRT2-1)/3;i[0]>0&&g.bezierCurveTo(f,E+c[0]*(e-1),f-c[0]*(e-1),E,f+c[0],E),g.lineTo(p-c[1],E),i[1]>0&&g.bezierCurveTo(p+c[1]*(e-1),E,p,E+c[1]*(e-1),p,E-c[1]),g.lineTo(p,_+c[2]),i[2]>0&&g.bezierCurveTo(p,_-c[2]*(e-1),p+c[2]*(e-1),_,p-c[2],_),g.lineTo(f+c[3],_),i[3]>0&&g.bezierCurveTo(f-c[3]*(e-1),_,f,_-c[3]*(e-1),f,_+c[3])}return g.lineTo(f,E-c[0]),(u=s>0?new THREE.ExtrudeBufferGeometry(g,{curveSegments:64,steps:1,depth:s,bevelEnabled:!0,bevelThickness:n,bevelSize:n,bevelOffset:0,bevelSegments:o}):new THREE.ShapeBufferGeometry(g,32)).userData={type:"RectangleGeometry",ui:{enabledIndieCorners:r},parameters:{width:e,height:t,depth:0,cornerRadius:i,cornerType:a,extrudeDepth:s,extrudeBevelSize:n,extrudeBevelSegments:o}},SPE.Math.fixUvs(u,e,t),u},this.buildFromGeometry=function(e,{width:t=e.userData.parameters.width,height:i=e.userData.parameters.height,cornerRadius:a=e.userData.parameters.cornerRadius,cornerType:r=e.userData.parameters.cornerType,enabledIndieCorners:s=e.userData.ui.enabledIndieCorners,extrudeDepth:n=e.userData.parameters.extrudeDepth,extrudeBevelSize:o=e.userData.parameters.extrudeBevelSize,extrudeBevelSegments:h=e.userData.parameters.extrudeBevelSegments}){return this.build({width:t,height:i,cornerRadius:a,cornerType:r,enabledIndieCorners:s,extrudeDepth:n,extrudeBevelSize:o,extrudeBevelSegments:h})}},SPE.SphereGeometry=new function(){this.build=function({width:e=100,height:t=e,depth:i=e,widthSegments:a=64,heightSegments:r=64,phiStart:s,phiLength:n,thetaStart:o,thetaLength:h}){e=Math.abs(e),t=Math.abs(t),i=Math.abs(i);let l=new THREE.SphereBufferGeometry(.5*e,a,r,s,n,o,h);return l.scale(1,t/e,i/e),l.userData={type:"SphereGeometry",parameters:{width:e,height:t,depth:i,widthSegments:a,heightSegments:r,phiStart:s,phiLength:n,thetaStart:o,thetaLength:h}},l},this.buildFromGeometry=function(e,{width:t=e.userData.parameters.width,height:i=e.userData.parameters.height,depth:a=e.userData.parameters.depth,widthSegments:r=e.userData.parameters.widthSegments,heightSegments:s=e.userData.parameters.heightSegments,phiStart:n=e.userData.parameters.phiStart,phiLength:o=e.userData.parameters.phiLength,thetaStart:h=e.userData.parameters.thetaStart,thetaLength:l=e.userData.parameters.thetaLength}){return this.build({width:t,height:i,depth:a,widthSegments:r,heightSegments:s,phiStart:n,phiLength:o,thetaStart:h,thetaLength:l})}},SPE.StarGeometry=new function(){this.build=function({width:e=100,height:t=e,innerRadiusPercent:i=38.19,spikes:a=5,cornerRadius:r=0,angle:s=360,extrudeDepth:n=0,extrudeBevelSize:o=0,extrudeBevelSegments:h=1}){let l,m=.5*(e=Math.abs(e)),d=.5*(t=Math.abs(t)),c=s*Math.PI/360/a,u=Math.PI/2*3*-1,f=m*i/100,p=d*i/100,E=new THREE.Shape;if(3==a&&50==i){c=2*Math.PI/a;for(let e=0;e<=a;e++){let t=c*e,i=0+Math.sin(t)*m,a=0+Math.cos(t)*d;E.lineTo(i,a)}}else{E.moveTo(0,0+s==360?d:0);for(let e=0;e<a;e++){let e=0+Math.cos(u)*m,t=0+Math.sin(u)*d;E.lineTo(e,t),u+=c,e=0+Math.cos(u)*f,t=0+Math.sin(u)*p,E.lineTo(e,t),u+=c}E.lineTo(0,0+s==360?d:0)}return 0!==r&&SPE.Geometry.Utils.roundShapePolygon(E,E.getPoints(),r),(l=n>0?new THREE.ExtrudeBufferGeometry(E,{steps:1,depth:n,bevelEnabled:!0,bevelThickness:o,bevelSize:o,bevelOffset:0,bevelSegments:h}):new THREE.ShapeBufferGeometry(E)).userData={type:"StarGeometry",parameters:{width:e,height:t,depth:0,innerRadiusPercent:i,spikes:a,cornerRadius:r,angle:s,extrudeDepth:n,extrudeBevelSize:o,extrudeBevelSegments:h}},SPE.Math.fixUvs(l,e,t),l},this.buildFromGeometry=function(e,{width:t=e.userData.parameters.width,height:i=e.userData.parameters.height,innerRadiusPercent:a=e.userData.parameters.innerRadiusPercent,spikes:r=e.userData.parameters.spikes,cornerRadius:s=e.userData.parameters.cornerRadius,angle:n=e.userData.parameters.angle,extrudeDepth:o=e.userData.parameters.extrudeDepth,extrudeBevelSize:h=e.userData.parameters.extrudeBevelSize,extrudeBevelSegments:l=e.userData.parameters.extrudeBevelSegments}){return this.build({width:t,height:i,innerRadiusPercent:a,spikes:r,cornerRadius:s,angle:n,extrudeDepth:o,extrudeBevelSize:h,extrudeBevelSegments:l})}},SPE.TorusGeometry=new function(){this.build=function({width:e=100,height:t=e,depth:i,tubePercent:a=50,radialSegments:r=32,tubularSegments:s=64,arc:n=2*Math.PI}){let o=.25*e*a*.01,h=.5*e-o;i=i||2*o;let l=new THREE.TorusBufferGeometry(h,o,r,s,n);return l.scale(1,t/e,i/(2*o)),l.userData={type:"TorusGeometry",parameters:{width:e,height:t,depth:i,tubePercent:a,radialSegments:r,tubularSegments:s,arc:n}},l},this.buildFromGeometry=function(e,{width:t=e.userData.parameters.width,height:i=e.userData.parameters.height,depth:a=e.userData.parameters.depth,tubePercent:r=e.userData.parameters.tubePercent,radialSegments:s=e.userData.parameters.radialSegments,tubularSegments:n=e.userData.parameters.tubularSegments,arc:o=e.userData.parameters.arc}){return this.build({width:t,height:i,depth:a,tubePercent:r,radialSegments:s,tubularSegments:n,arc:o})}},SPE.LatheGeometry=new function(){this.build=function({width:e=100,height:t=e,depth:i=e,segments:a=64,points:r=[{x:0,y:-50,id:0},{x:50,y:-50,id:1},{x:50,y:50,id:2},{x:0,y:50,id:3}]}){let s=new THREE.Shape;s.moveTo(r[0].x,r[0].y),s.bezierCurveTo(r[1].x,r[1].y,r[2].x,r[2].y,r[3].x,r[3].y);let n=new THREE.LatheBufferGeometry(s.extractPoints(16).shape,a);return n.rotateZ(Math.PI),n.userData={type:"LatheGeometry",parameters:{width:e,height:t,depth:i,segments:a,points:r}},n},this.buildFromGeometry=function(e,{width:t=e.userData.parameters.width,height:i=e.userData.parameters.height,depth:a=e.userData.parameters.depth,segments:r=e.userData.parameters.segments,points:s=e.userData.parameters.points}){return this.build({width:t,height:i,depth:a,segments:r,points:s})}},SPE.HelixGeometry=new function(){this.build=function({height:e=80,width:t=10,depth:i=10,radius:a=20,revolutions:r=3,segments:s=120,pathRadius:n=15,pathType:o=0,pathSegments:h=12,cornerRadius:l=30,cornerSegments:m=8}){e=Math.abs(e),t=Math.abs(t),i=Math.abs(i),a=Math.abs(a),r=Math.abs(r),s=Math.abs(s),n=Math.abs(n),o=Math.abs(o),h=Math.abs(h),l=Math.abs(l),m=Math.abs(m);let d=function(){s=Math.round(s),h=Math.round(h),m=Math.round(m);let a=e,o=t,d=i,c=r,u=s,f=n,p=h,E=l,_=m;const g=[],y=[],v=[],S=[],T=[];let R,I,w,b,L,x,M,P,A=new THREE.Vector3,$=new THREE.Vector3,O=new THREE.Vector3,U=new THREE.Vector3,D=(new THREE.Vector3,new THREE.Vector3),C=new THREE.Vector3,H=new THREE.Vector3,G=new THREE.Vector3,N=new THREE.Vector3,B=new THREE.Vector3,z=new THREE.Vector3;const Y=a-2*f,V=Y/c,F=Y/u,j=-Y/2,k=2*Math.PI/p,W=Math.PI/2/_,X=Math.min((1-E/100)*f,f-.1),q=f-X;function K(e){return x=e*F+j,P=2*Math.PI*(x%V)/V,L=Math.cos(P)*(o/2-f),M=Math.sin(P)*(d/2-f),[L,x,M]}D.set(...K(-1));for(let e=0;e<=u;e++){A.set(...K(e)),z.subVectors(A,D).normalize(),D.copy(A),N.set(A.x,0,A.z).normalize(),B.crossVectors(z,N).normalize();for(let t=0,i=0;t<p;i=++t*k){if(C.addVectors(O.copy(N).multiplyScalar(f*Math.cos(i)),U.copy(B).multiplyScalar(f*Math.sin(i))),G.copy(C).normalize(),0==e||e==u){U.copy(G).multiplyScalar(X),$.addVectors(A,U);let t=0==e?3*Math.PI/2:W;for(let e=0,i=t;e<_;i=++e*W+t)H.addVectors(O.copy(z).multiplyScalar(q*Math.sin(i)),U.copy(G).multiplyScalar(q*Math.cos(i))),U.addVectors($,H),H.normalize(),S.push(U.x,U.y,U.z),T.push(H.x,H.y,H.z)}U.addVectors(A,C),y.push(U.x,U.y,U.z),v.push(G.x,G.y,G.z)}}for(let e=0;e<u;e++)for(let t=0;t<p;t++)w=(R=e*p+t)+p,b=(I=e*p+(t+1)%p)+p,g.push(R,I,w,I,b,w);const Z=y.concat(S),Q=v.concat(T),J=y.length/3,ee=J+S.length/3/2;let te=(e,t)=>J+(e+1)*_-t,ie=(e,t)=>ee+e*_+t;for(let e=0;e<_;e++)for(let t=0;t<p;t++)L=t,x=(t+1)%p,R=e?te(L,e):L,I=e?te(x,e):x,w=e?R-1:te(R,1),b=e?I-1:te(I,1),g.push(R,w,I,I,w,b),R=e?ie(L,e-1):J-p+L,I=e?ie(x,e-1):J-p+x,w=e?R+1:ie(L,0),b=e?I+1:ie(x,0),g.push(R,I,w,I,b,w);R=J,I=ee+_-1;for(let e=0;e<p-2;e++)w=(e+1)*_,b=(e+2)*_,g.push(R,R+b,R+w),g.push(I,I+w,I+b);let ae=new THREE.BufferGeometry;return ae.setIndex(g),ae.setAttribute("position",new THREE.Float32BufferAttribute(Z,3)),ae.setAttribute("normal",new THREE.Float32BufferAttribute(Q,3)),ae}();return d.userData={type:"HelixGeometry",parameters:{height:e,width:t,depth:i,radius:a,revolutions:r,segments:s,pathRadius:n,pathType:o,pathSegments:h,cornerRadius:l,cornerSegments:m}},d},this.buildFromGeometry=function(e,{height:t=e.userData.parameters.height,width:i=e.userData.parameters.width,depth:a=e.userData.parameters.depth,radius:r=e.userData.parameters.radius,revolutions:s=e.userData.parameters.revolutions,segments:n=e.userData.parameters.segments,pathRadius:o=e.userData.parameters.pathRadius,pathType:h=e.userData.parameters.pathType,pathSegments:l=e.userData.parameters.pathSegments,cornerRadius:m=e.userData.parameters.cornerRadius,cornerSegments:d=e.userData.parameters.cornerSegments}){return this.build({height:t,width:i,depth:a,radius:r,revolutions:s,segments:n,pathRadius:o,pathType:h,pathSegments:l,cornerRadius:m,cornerSegments:d})}},SPE.TriangleGeometry=new function(){this.build=function({width:e=100,height:t,cornerRadius:i=0,extrudeDepth:a=0,extrudeBevelSize:r=0,extrudeBevelSegments:s=1}){let n,o={x:.5*(e=Math.abs(e)),y:.5*(t=(t=Math.abs(t))||e*(Math.sqrt(3)/2))},h=new THREE.Shape;return h.moveTo(0,o.y),h.lineTo(o.x,-o.y),h.lineTo(-o.x,-o.y),h.lineTo(0,o.y),0!==i&&function(e,t,i){var a,r,s,n,o,h,l,m,d,c,u,f,p,E,_,g,y,v=function(e,t,i){i.x=t.x-e.x,i.y=t.y-e.y,i.len=Math.sqrt(i.x*i.x+i.y*i.y),i.nx=i.x/i.len,i.ny=i.y/i.len,i.ang=Math.atan2(i.ny,i.nx)};for(m={},d={},n=t.length-1,o=t[n-1],e.curves=[],a=0;a<n;a++)h=t[a%n],l=t[(a+1)%n],v(h,o,m),v(h,l,d),c=m.nx*d.ny-m.ny*d.nx,u=m.nx*d.nx-m.ny*-d.ny,E=Math.asin(c),f=1,p=!1,u<0?E<0?E=Math.PI+E:(E=Math.PI-E,f=-1,p=!0):E>0&&(f=-1,p=!0),_=.5*E,(y=Math.abs(Math.cos(_)*i/Math.sin(_)))>Math.min(.5*m.len,.5*d.len)?(y=Math.min(.5*m.len,.5*d.len),g=Math.abs(y*Math.sin(_)/Math.cos(_))):g=i,r=h.x+d.nx*y,s=h.y+d.ny*y,r+=-d.ny*g*f,s+=d.nx*g*f,e.absarc(r,s,g,m.ang+Math.PI/2*f,d.ang-Math.PI/2*f,p),o=h,h=l;e.closePath()}(h,h.getPoints(),i),(n=a>0?new THREE.ExtrudeBufferGeometry(h,{curveSegments:64,steps:1,depth:a,bevelEnabled:!0,bevelThickness:r,bevelSize:r,bevelOffset:0,bevelSegments:s}):new THREE.ShapeBufferGeometry(h,32)).userData={type:"TriangleGeometry",parameters:{width:e,height:t,depth:0,cornerRadius:i,extrudeDepth:a,extrudeBevelSize:r,extrudeBevelSegments:s}},SPE.Math.fixUvs(n,e,t),n},this.buildFromGeometry=function(e,{width:t=e.userData.parameters.width,height:i=e.userData.parameters.height,cornerRadius:a=e.userData.parameters.cornerRadius,extrudeDepth:r=e.userData.parameters.extrudeDepth,extrudeBevelSize:s=e.userData.parameters.extrudeBevelSize,extrudeBevelSegments:n=e.userData.parameters.extrudeBevelSegments}){return this.build({width:t,height:i,cornerRadius:a,extrudeDepth:r,extrudeBevelSize:s,extrudeBevelSegments:n})}},SPE.NonParametricGeometry=new function(){this.build=function(e=new THREE.BoxBufferGeometry(100,100,100),t){let i=new THREE.BufferGeometry;i.copy(e);const a=new THREE.Vector3;if(i.computeBoundingBox(),i.boundingBox.getSize(a),t){var r=t.width?t.width:a.x,s=t.height?t.height:a.y,n=t.depth?t.depth:a.z;i.scale(0===a.x?1:r/a.x,0===a.y?1:s/a.y,0===a.z?1:n/a.z)}else r=a.x,s=a.y,n=a.z;return i.userData={type:"NonParametricGeometry",parameters:{width:r,height:s,depth:n}},i},this.buildFromGeometry=function(e,{width:t=e.userData.parameters.width,height:i=e.userData.parameters.height,depth:a=e.userData.parameters.depth}){return this.build(e,{width:t,height:i,depth:a})}},SPE.StrokeGeometry=new function(){this.build=function(e,t={}){const i=t.strokeAlignment||1,a=t.strokeGrowth||1,r=[];switch(e.userData.type){case"PolygonGeometry":var s=3,n=e.getAttribute("position").array.length-3;break;case"StarGeometry":s=0,n=e.getAttribute("position").array.length-3;break;default:s=0,n=e.getAttribute("position").array.length}for(let t=s;t<n;t+=3)r.push([e.getAttribute("position").array[t],e.getAttribute("position").array[t+1]]);const o=createLineGeo(r,i,a)(THREE);return o.userData={type:"StrokeGeometry",parameters:{strokeAlignment:i}},o.toJSON=function(){const t={};return t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),t.userData=this.userData,t.userData.meshGeometry=e.uuid,t},o},this.buildFromGeometry=function(e,t,{strokeAlignment:i=t.userData.parameters.strokeAlignment,strokeGrowth:a=t.userData.parameters.strokeGrowth}){return SPE.StrokeGeometry.build(e,{strokeAlignment:i,strokeGrowth:a})}},SPE.TextFrameGeometry=new function(){this.build=function({width:e=100,height:t=e}){let i=new THREE.PlaneBufferGeometry(e,t);return i.userData={type:"TextFrameGeometry",parameters:{width:e,height:t,depth:0}},i},this.buildFromGeometry=function(e,{width:t=e.userData.parameters.width,height:i=e.userData.parameters.height}){return this.build({width:t,height:i})}},SPE.Geometry={},SPE.Geometry.Utils=new function(){this.roundShapePolygon=function(e,t,i){var a,r,s,n,o,h,l,m,d,c,u,f,p,E,_,g,y,v=function(e,t,i){i.x=t.x-e.x,i.y=t.y-e.y,i.len=Math.sqrt(i.x*i.x+i.y*i.y),i.nx=i.x/i.len,i.ny=i.y/i.len,i.ang=Math.atan2(i.ny,i.nx)};for(m={},d={},o=t[(n=t.length)-2],e.curves=[],a=1;a<n-1;a++)h=t[a%n],l=t[(a+1)%n],v(h,o,m),v(h,l,d),c=m.nx*d.ny-m.ny*d.nx,u=m.nx*d.nx-m.ny*-d.ny,E=Math.asin(c),f=1,p=!1,u<0?E<0?E=Math.PI+E:(E=Math.PI-E,f=-1,p=!0):E>0&&(f=-1,p=!0),_=E/2,(y=Math.abs(Math.cos(_)*i/Math.sin(_)))>Math.min(m.len/2,d.len/2)?(y=Math.min(m.len/2,d.len/2),g=Math.abs(y*Math.sin(_)/Math.cos(_))):g=i,r=h.x+d.nx*y,s=h.y+d.ny*y,r+=-d.ny*g*f,s+=d.nx*g*f,e.absarc(r,s,g,m.ang+Math.PI/2*f,d.ang-Math.PI/2*f,p),o=h,h=l;e.closePath()},this.resizeGeometry=function(e,{width:t,height:i,depth:a}){t=Math.abs(t),i=Math.abs(i),a=Math.abs(a);const r=e.userData.parameters;let s,n,o;0===t?(t=r.width,s=1):s=t/r.width,0===i?(i=r.height,n=1):n=i/r.height,0===a?(a=r.depth,o=1):o=a/r.depth,e.scale(s,n,o),r.width=t,r.height=i,r.depth=a},this.addBarycentricAttribute=function(e,t){const i=[new THREE.Vector3(1,0,0),new THREE.Vector3(0,1,0),new THREE.Vector3(0,0,1)],a=e.attributes.position,r=new Float32Array(3*a.count);for(let e=0,t=a.count;e<t;e++)i[e%3].toArray(r,3*e);e.setAttribute(t,new THREE.Float32BufferAttribute(r,3))},this.removeBarycentricAttribute=function(e,t){e.deleteAttribute(t)},this.loadFromUrl=function(e){return new Promise(function(t,i){(new THREE.BufferGeometryLoader).load(e,function(e){t(e)})})}};class Cloner extends THREE.Object3D{constructor(e,t={}){super(),this.object=e,this.userData.type="Cloner",this.userData.skip=!0;const i=e.geometry.userData.parameters.width,a=e.geometry.userData.parameters.height,r=e.geometry.userData.parameters.depth;this.parameters={type:void 0!==t.type?t.type:"radial",hideBase:void 0!==t.hideBase&&t.hideBase,count:void 0!==t.count?t.count:3,ra_radius:void 0!==t.ra_radius?t.ra_radius:2*i,ra_startAngle:void 0!==t.ra_startAngle?t.ra_startAngle:0,ra_endAngle:void 0!==t.ra_endAngle?t.ra_endAngle:360,ra_align:void 0!==t.ra_align&&t.ra_align,ra_axis:void 0!==t.ra_axis?t.ra_axis:"y",ra_scale:void 0!==t.ra_scale?t.ra_scale.clone():new THREE.Vector3,ra_rotation:void 0!==t.ra_rotation?t.ra_rotation.clone():new THREE.Euler,ra_position:void 0!==t.ra_position?t.ra_position.clone():new THREE.Vector3,li_scale:void 0!==t.li_scale?t.li_scale.clone():new THREE.Vector3,li_rotation:void 0!==t.li_rotation?t.li_rotation.clone():new THREE.Euler,li_position:void 0!==t.li_position?t.li_position.clone():new THREE.Vector3(i+.1*i,0,0).round(),gr_count:void 0!==t.gr_count?t.gr_count.clone():new THREE.Vector3(2,2,2),gr_size:void 0!==t.gr_size?t.gr_size.clone():new THREE.Vector3(i+.1*i,a+.1*a,r+.1*r).round(),gr_fromCenter:void 0===t.gr_fromCenter||t.gr_fromCenter},this.update(),this.setHideBase(this.parameters.hideBase)}setHideBase(e){if(this.children.length>0)if(this.object.material.visible=!0,!0===e){const e=this.object.material.clone();for(let t=0,i=this.children.length;t<i;++t)this.children[t].material=e}else{this.children[0].material.dispose();for(let e=0,t=this.children.length;e<t;++e)this.children[e].material=this.object.material}this.object.material.visible=!e,this.parameters.hideBase=e}update(){switch(this._updateCount(),this.parameters.type){case"radial":this._updateRadial();break;case"linear":this._updateLinear();break;case"grid":this._updateGrid()}}_updateCount(){const e=this.parameters,t="grid"===e.type?e.gr_count.x*e.gr_count.y*e.gr_count.z:e.count;if(this.children.length!==t)if(this.children.length<t)for(let e=0,i=t-this.children.length;e<i;++e){const e=this.object.shallowClone();delete e.userData.isEntity,this.add(e)}else for(let e=0,i=this.children.length-t;e<i;++e)this.remove(this.children[0])}_updateRadial(){const e=this.parameters,t=e.ra_startAngle*THREE.Math.DEG2RAD,i=t-e.ra_endAngle*THREE.Math.DEG2RAD,a=new THREE.Euler(e.ra_rotation.x*THREE.Math.DEG2RAD,e.ra_rotation.y*THREE.Math.DEG2RAD,e.ra_rotation.z*THREE.Math.DEG2RAD);let r;"x"==e.ra_axis&&(r=new THREE.Vector3(1,0,0)),"y"==e.ra_axis&&(r=new THREE.Vector3(0,1,0)),"z"==e.ra_axis&&(r=new THREE.Vector3(0,0,1));for(let s=0;s<e.count;s++){const n=this.children[s];n.hiddenMatrix.identity(),n.scale.x=e.ra_scale.x+1,n.scale.y=e.ra_scale.y+1,n.scale.z=e.ra_scale.z+1,n.position.setScalar(0);const o=i/e.count*s-t;"x"==e.ra_axis&&n.rotation.set(0,o,0),"y"==e.ra_axis&&n.rotation.set(0,0,o),"z"==e.ra_axis&&n.rotation.set(o,0,0),n.translateOnAxis(r,e.ra_radius),n.position.add(e.ra_position),!0===e.ra_align?(n.rotation.x+=a.x,n.rotation.y+=a.y,n.rotation.z+=a.z):n.rotation.copy(a)}}_updateLinear(){const e=this.parameters,t=new THREE.Euler(e.li_rotation.x*THREE.Math.DEG2RAD,e.li_rotation.y*THREE.Math.DEG2RAD,e.li_rotation.z*THREE.Math.DEG2RAD);for(let i=0;i<e.count;i++){const a=this.children[i];a.hiddenMatrix.identity(),a.scale.x=e.li_scale.x*i+1,a.scale.y=e.li_scale.y*i+1,a.scale.z=e.li_scale.z*i+1,a.rotation.x=t.x*i,a.rotation.y=t.y*i,a.rotation.z=t.z*i,a.position.x=e.li_position.x*i,a.position.y=e.li_position.y*i,a.position.z=e.li_position.z*i}}_updateGrid(){const e=this.parameters;let t=0;if(!0===e.gr_fromCenter){const i={x:e.gr_count.x%2==0?2:1,y:e.gr_count.y%2==0?2:1,z:e.gr_count.z%2==0?2:1},a=new THREE.Vector3(e.gr_size.x*(e.gr_count.x-i.x)*.5,e.gr_size.y*(e.gr_count.y-i.y)*.5,e.gr_size.z*(e.gr_count.z-i.z)*.5);for(let i=0;i<e.gr_count.x;i++)for(let r=0;r<e.gr_count.y;r++)for(let s=0;s<e.gr_count.z;s++){const n=this.children[t++];n.hiddenMatrix.identity(),n.scale.setScalar(1),n.rotation.set(0,0,0),n.position.x=e.gr_size.x*i-a.x,n.position.y=e.gr_size.y*r-a.y,n.position.z=e.gr_size.z*s-a.z}}else for(let i=0;i<e.gr_count.x;i++)for(let a=0;a<e.gr_count.y;a++)for(let r=0;r<e.gr_count.z;r++){const s=this.children[t++];s.hiddenMatrix.identity(),s.scale.setScalar(1),s.rotation.set(0,0,0),s.position.x=e.gr_size.x*i,s.position.y=-e.gr_size.y*a,s.position.z=-e.gr_size.z*r}}toJSON(){const e=this.parameters,t={};return t.parameters={type:e.type,hideBase:e.hideBase,count:e.count,ra_radius:e.ra_radius,ra_startAngle:e.ra_startAngle,ra_endAngle:e.ra_endAngle,ra_align:e.ra_align,ra_axis:e.ra_axis,ra_scale:e.ra_scale.toArray(),ra_rotation:e.ra_rotation.toArray(),ra_position:e.ra_position.toArray(),li_scale:e.li_scale.toArray(),li_rotation:e.li_rotation.toArray(),li_position:e.li_position.toArray(),gr_count:e.gr_count.toArray(),gr_size:e.gr_size.toArray(),gr_fromCenter:e.gr_fromCenter},t}fromJSON(e){const t=e.parameters;return this.parameters={type:t.type,hideBase:t.hideBase,count:t.count,ra_radius:t.ra_radius,ra_startAngle:t.ra_startAngle,ra_endAngle:t.ra_endAngle,ra_align:t.ra_align,ra_axis:t.ra_axis,ra_scale:(new THREE.Vector3).fromArray(t.ra_scale),ra_rotation:(new THREE.Vector3).fromArray(t.ra_rotation),ra_position:(new THREE.Vector3).fromArray(t.ra_position),li_scale:(new THREE.Vector3).fromArray(t.li_scale),li_rotation:(new THREE.Vector3).fromArray(t.li_rotation),li_position:(new THREE.Vector3).fromArray(t.li_position),gr_count:(new THREE.Vector3).fromArray(t.gr_count),gr_size:(new THREE.Vector3).fromArray(t.gr_size),gr_fromCenter:t.gr_fromCenter},this.update(),this.setHideBase(this.parameters.hideBase),this}}SPE.Raycaster=class extends THREE.Raycaster{setFromCamera(e,t){t&&t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t&&t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,-1).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type.")}createRaycastLineHelper(){const e=new THREE.LineBasicMaterial({color:16711680,linewidth:10}),t=new THREE.Geometry,i=new THREE.Vector3(this.ray.origin.x,this.ray.origin.y,this.ray.origin.z),a=new THREE.Vector3(this.ray.direction.x,this.ray.direction.y,this.ray.direction.z),r=(new THREE.Vector3).lerpVectors(i,a,.5);return a.multiplyScalar(0),t.vertices.push(i),t.vertices.push(r),t.vertices.push(a),new THREE.Line(t,e)}},SPE.Math=class{static slerp(e,t,i,a){if(0===a)return i.copy(e);if(1===a)return i.copy(t);var r=e.w*t.w+e.x*t.x+e.y*t.y+e.z*t.z;if(r>=1)return i.copy(e);var s=1-r*r;if(s<=Number.EPSILON){var n=1-a;return i.w=n*e.w+a*t.w,i.x=n*e.x+a*t.x,i.y=n*e.y+a*t.y,i.z=n*e.z+a*t.z,i.normalize(),i}var o=Math.sqrt(s),h=Math.atan2(o,r),l=Math.sin((1-a)*h)/o,m=Math.sin(a*h)/o;return i.w=e.w*l+t.w*m,i.x=e.x*l+t.x*m,i.y=e.y*l+t.y*m,i.z=e.z*l+t.z*m,i}static getRandomInt(e,t){return e=Math.ceil(e),t=Math.floor(t),Math.floor(Math.random()*(t-e)+e)}static getProjection(e,t,i){let a=e.clone().sub(t),r=i.clone().sub(t),s=t.distanceTo(i);return a.dot(r)/s}static projectOnVector(e,t){return e.clone().dot(t)/t.length()}static angle2D(e,t,i,a,r=!1){let s=i-e,n=a-t,o=Math.atan2(n,s);return o*=180/Math.PI,r&&o<0&&(o=360+o),o}static angle3D(e,t,i){let a=e.clone().sub(t),r=i.clone().sub(t),s=t.distanceTo(e),n=t.distanceTo(i),o=a.dot(r)/(s*n);return Math.acos(o)}static rotatePosition2D(e,t,i){return{x:e*Math.cos(i)-t*Math.sin(i),y:e*Math.sin(i)+t*Math.cos(i),z:0}}static rotatePosition3D(e,t){return e.clone().applyMatrix3(SPE.Math.getRotateMatrix(t.x,t.y,t.z))}static getRotateMatrix(e,t,i){let a=new THREE.Matrix3,r=new THREE.Matrix3,s=new THREE.Matrix3;return a.set(1,0,0,0,Math.cos(e),-Math.sin(e),0,Math.sin(e),Math.cos(e)),r.set(Math.cos(t),0,Math.sin(t),0,1,0,-Math.sin(t),0,Math.cos(t)),s.set(Math.cos(i),-Math.sin(i),0,Math.sin(i),Math.cos(i),0,0,0,1),a.multiply(r).multiply(s)}static round(e,t){let i=(e+"e").split("e");return+((i=(Math.round(i[0]+"e"+(+i[1]+t))+"e").split("e"))[0]+"e"+(+i[1]-t))}static normalize(e,t,i){return(e-t)/(i-t)}static lerp(e,t,i){return(i-t)*e+t}static map(e,t,i,a,r){return SPE.Math.lerp(SPE.Math.normalize(e,t,i),a,r)}static clamp(e,t,i){return Math.min(Math.max(e,t),i)}static getMiddlePointByPerc(e,t,i){let a=t.clone().sub(e),r=a.length();return a=a.normalize().multiplyScalar(r*i),e.clone().add(a)}static getVectorDistanceInFloat(e,t){let i=e.x-t.x,a=e.y-t.y,r=e.z-t.z;return Math.sqrt(i*i+a*a+r*r)}static getVectorDistanceInVector(e,t){let i=e.x-t.x,a=e.y-t.y,r=e.z-t.z;return new THREE.Vector3(i,a,r)}static getObjectSize(e){let t=new THREE.Vector3;return e.geometry.computeBoundingBox(),t.x=e.geometry.boundingBox.max.x-e.geometry.boundingBox.min.x,t.y=e.geometry.boundingBox.max.y-e.geometry.boundingBox.min.y,t.z=e.geometry.boundingBox.max.z-e.geometry.boundingBox.min.z,t}static resetTransform(e,t){for(let i=0;i<t.length;i++)"all"==e?(t[i].position.set(0,0,0),t[i].scale.set(1,1,1),t[i].rotation.set(0,0,0)):"scale"==e?t[i].scale.set(1,1,1):t[i].rotation.set(0,0,0),t[i].geometry&&t[i].geometry.computeBoundingBox()}static containsObject(e,t){for(let i=0;i<t.length;i++)if(t[i]===e)return!0;return!1}static findCentroid(e){let t=new THREE.Vector3,i=e.length;for(let i=0;i<e.length;i++)t.set(t.x+e[i].position.x,t.y+e[i].position.y,t.z+e[i].position.z);return t.set(t.x/i,t.y/i,t.z/i),t}static removeFromArray(e,t){const i=e.indexOf(t);e.splice(i,1)}static getPositionRelativeToElement(e){let t=e.target.getBoundingClientRect();return{mx:e.clientX-t.left,my:e.clientY-t.top}}static getElementMousePos(e,t){return{mx:t.pageX-e.offset().left,my:t.pageY-e.offset().top}}static changeColor(e,t){let i=e.geometry.attributes.color.array,a=3*e.geometry.attributes.color.count,r=1/(t.steps*a),s=new THREE.Color;for(let e=0,n=a;e<n;e++)s.set(makeColorGradient(e,r,t.phase)),i[3*e]=s.r,i[3*e+1]=s.g,i[3*e+2]=s.b;e.geometry.attributes.color.needsUpdate=!0}static getColoredBufferLine(e,t,i){let a,r,s,n=i.vertices,o=i.vertices.length,h=new THREE.BufferGeometry,l=new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors}),m=new Float32Array(3*o),d=new Float32Array(3*o),c=1/(e*o),u=new THREE.Color;for(let e=0,i=o;e<i;e++)a=n[e].x,r=n[e].y,s=n[e].z,m[3*e]=a,m[3*e+1]=r,m[3*e+2]=s,u.set(makeColorGradient(e,c,t)),d[3*e]=u.r,d[3*e+1]=u.g,d[3*e+2]=u.b;return h.setAttribute("position",new THREE.BufferAttribute(m,3)),h.setAttribute("color",new THREE.BufferAttribute(d,3)),new THREE.Line(h,l)}static makeColorGradient(e,t,i){let a,r,s;r=s=a=t;let n=i+2,o=i+4,h=127*Math.sin(a*e+i)+128,l=127*Math.sin(r*e+n)+128,m=127*Math.sin(s*e+o)+128;return parseInt("0x"+_byte2Hex(h)+_byte2Hex(l)+_byte2Hex(m))}static _byte2Hex(e){return String("0123456789ABCDEF".substr(e>>4&15,1))+"0123456789ABCDEF".substr(15&e,1)}static drawBezierTangent(e,t){let i=new THREE.LineCurve3(e,t).getPoints(1),a=(new THREE.BufferGeometry).setFromPoints(i);return new THREE.Line(a,new THREE.LineBasicMaterial({color:16711680}))}static fixUvs(e,t,i){for(let a=0;a<e.attributes.uv.array.length;a+=2)e.attributes.uv.array[a]=(e.attributes.uv.array[a]+t/2)/t,e.attributes.uv.array[a+1]=1-(e.attributes.uv.array[a+1]-i/2)/i*-1}static flattenArray(e){return e=[].concat.apply([],e)}static sortNumber(e,t){return e-t}static swapArrayValues(e,t,i){let a=e[t];e[t]=e[i],e[i]=a}};